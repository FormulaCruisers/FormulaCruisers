
Can_Node_Module_v4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000008  00800100  000009dc  00000a70  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000009dc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000010  00800108  00800108  00000a78  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000a78  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000aa8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c0  00000000  00000000  00000ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001252  00000000  00000000  00000ba8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000db2  00000000  00000000  00001dfa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000009c3  00000000  00000000  00002bac  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001e8  00000000  00000000  00003570  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000062b  00000000  00000000  00003758  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a08  00000000  00000000  00003d83  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000098  00000000  00000000  0000478b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	49 c0       	rjmp	.+146    	; 0x94 <__ctors_end>
   2:	00 00       	nop
   4:	64 c0       	rjmp	.+200    	; 0xce <__bad_interrupt>
   6:	00 00       	nop
   8:	62 c0       	rjmp	.+196    	; 0xce <__bad_interrupt>
   a:	00 00       	nop
   c:	60 c0       	rjmp	.+192    	; 0xce <__bad_interrupt>
   e:	00 00       	nop
  10:	5e c0       	rjmp	.+188    	; 0xce <__bad_interrupt>
  12:	00 00       	nop
  14:	5c c0       	rjmp	.+184    	; 0xce <__bad_interrupt>
  16:	00 00       	nop
  18:	5a c0       	rjmp	.+180    	; 0xce <__bad_interrupt>
  1a:	00 00       	nop
  1c:	58 c0       	rjmp	.+176    	; 0xce <__bad_interrupt>
  1e:	00 00       	nop
  20:	56 c0       	rjmp	.+172    	; 0xce <__bad_interrupt>
  22:	00 00       	nop
  24:	54 c0       	rjmp	.+168    	; 0xce <__bad_interrupt>
  26:	00 00       	nop
  28:	52 c0       	rjmp	.+164    	; 0xce <__bad_interrupt>
  2a:	00 00       	nop
  2c:	50 c0       	rjmp	.+160    	; 0xce <__bad_interrupt>
  2e:	00 00       	nop
  30:	4e c0       	rjmp	.+156    	; 0xce <__bad_interrupt>
  32:	00 00       	nop
  34:	4c c0       	rjmp	.+152    	; 0xce <__bad_interrupt>
  36:	00 00       	nop
  38:	4a c0       	rjmp	.+148    	; 0xce <__bad_interrupt>
  3a:	00 00       	nop
  3c:	48 c0       	rjmp	.+144    	; 0xce <__bad_interrupt>
  3e:	00 00       	nop
  40:	46 c0       	rjmp	.+140    	; 0xce <__bad_interrupt>
  42:	00 00       	nop
  44:	44 c0       	rjmp	.+136    	; 0xce <__bad_interrupt>
  46:	00 00       	nop
  48:	3d c1       	rjmp	.+634    	; 0x2c4 <__vector_18>
  4a:	00 00       	nop
  4c:	40 c0       	rjmp	.+128    	; 0xce <__bad_interrupt>
  4e:	00 00       	nop
  50:	3e c0       	rjmp	.+124    	; 0xce <__bad_interrupt>
  52:	00 00       	nop
  54:	3c c0       	rjmp	.+120    	; 0xce <__bad_interrupt>
  56:	00 00       	nop
  58:	3a c0       	rjmp	.+116    	; 0xce <__bad_interrupt>
  5a:	00 00       	nop
  5c:	38 c0       	rjmp	.+112    	; 0xce <__bad_interrupt>
  5e:	00 00       	nop
  60:	36 c0       	rjmp	.+108    	; 0xce <__bad_interrupt>
  62:	00 00       	nop
  64:	4b c0       	rjmp	.+150    	; 0xfc <__vector_25>
  66:	00 00       	nop
  68:	32 c0       	rjmp	.+100    	; 0xce <__bad_interrupt>
  6a:	00 00       	nop
  6c:	30 c0       	rjmp	.+96     	; 0xce <__bad_interrupt>
  6e:	00 00       	nop
  70:	2e c0       	rjmp	.+92     	; 0xce <__bad_interrupt>
  72:	00 00       	nop
  74:	2c c0       	rjmp	.+88     	; 0xce <__bad_interrupt>
  76:	00 00       	nop
  78:	2a c0       	rjmp	.+84     	; 0xce <__bad_interrupt>
  7a:	00 00       	nop
  7c:	28 c0       	rjmp	.+80     	; 0xce <__bad_interrupt>
  7e:	00 00       	nop
  80:	26 c0       	rjmp	.+76     	; 0xce <__bad_interrupt>
  82:	00 00       	nop
  84:	24 c0       	rjmp	.+72     	; 0xce <__bad_interrupt>
  86:	00 00       	nop
  88:	22 c0       	rjmp	.+68     	; 0xce <__bad_interrupt>
  8a:	00 00       	nop
  8c:	20 c0       	rjmp	.+64     	; 0xce <__bad_interrupt>
  8e:	00 00       	nop
  90:	1e c0       	rjmp	.+60     	; 0xce <__bad_interrupt>
	...

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d0 e1       	ldi	r29, 0x10	; 16
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
  a0:	11 e0       	ldi	r17, 0x01	; 1
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	ec ed       	ldi	r30, 0xDC	; 220
  a8:	f9 e0       	ldi	r31, 0x09	; 9
  aa:	00 e0       	ldi	r16, 0x00	; 0
  ac:	0b bf       	out	0x3b, r16	; 59
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <__do_copy_data+0x14>
  b0:	07 90       	elpm	r0, Z+
  b2:	0d 92       	st	X+, r0
  b4:	a8 30       	cpi	r26, 0x08	; 8
  b6:	b1 07       	cpc	r27, r17
  b8:	d9 f7       	brne	.-10     	; 0xb0 <__do_copy_data+0x10>

000000ba <__do_clear_bss>:
  ba:	21 e0       	ldi	r18, 0x01	; 1
  bc:	a8 e0       	ldi	r26, 0x08	; 8
  be:	b1 e0       	ldi	r27, 0x01	; 1
  c0:	01 c0       	rjmp	.+2      	; 0xc4 <.do_clear_bss_start>

000000c2 <.do_clear_bss_loop>:
  c2:	1d 92       	st	X+, r1

000000c4 <.do_clear_bss_start>:
  c4:	a8 31       	cpi	r26, 0x18	; 24
  c6:	b2 07       	cpc	r27, r18
  c8:	e1 f7       	brne	.-8      	; 0xc2 <.do_clear_bss_loop>
  ca:	2d d4       	rcall	.+2138   	; 0x926 <main>
  cc:	85 c4       	rjmp	.+2314   	; 0x9d8 <_exit>

000000ce <__bad_interrupt>:
  ce:	98 cf       	rjmp	.-208    	; 0x0 <__vectors>

000000d0 <int_ADC>:
#include "ADC.h"

uint16_t ADCValue[4] = {0x10,0x20,0x30,0x40};

void int_ADC(void){
	DDRF	= 0x00;
  d0:	10 ba       	out	0x10, r1	; 16
	PORTF	= 0x00;
  d2:	11 ba       	out	0x11, r1	; 17
	
	ADMUX	= ( 1 << REFS0 )
  d4:	80 ec       	ldi	r24, 0xC0	; 192
  d6:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
			| ( 0 << MUX3 )
			| ( 0 << MUX2 )
			| ( 0 << MUX1 )
			| ( 0 << MUX0 );
			
	ADCSRA	= ( 1 << ADEN )
  da:	8f e8       	ldi	r24, 0x8F	; 143
  dc:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
  e0:	08 95       	ret

000000e2 <getADC>:
			| ( 1 << ADPS1 )
			| ( 1 << ADPS0 );
}

void getADC(uint8_t ADC_pin){
	ADMUX	= (ADMUX & 0b11111100) | (ADC_pin & 0b00000011);
  e2:	ec e7       	ldi	r30, 0x7C	; 124
  e4:	f0 e0       	ldi	r31, 0x00	; 0
  e6:	90 81       	ld	r25, Z
  e8:	83 70       	andi	r24, 0x03	; 3
  ea:	9c 7f       	andi	r25, 0xFC	; 252
  ec:	89 2b       	or	r24, r25
  ee:	80 83       	st	Z, r24
	ADCSRA |= ( 1 << ADSC);
  f0:	ea e7       	ldi	r30, 0x7A	; 122
  f2:	f0 e0       	ldi	r31, 0x00	; 0
  f4:	80 81       	ld	r24, Z
  f6:	80 64       	ori	r24, 0x40	; 64
  f8:	80 83       	st	Z, r24
  fa:	08 95       	ret

000000fc <__vector_25>:
}


ISR(ADC_vect){
  fc:	1f 92       	push	r1
  fe:	0f 92       	push	r0
 100:	0f b6       	in	r0, 0x3f	; 63
 102:	0f 92       	push	r0
 104:	11 24       	eor	r1, r1
 106:	0b b6       	in	r0, 0x3b	; 59
 108:	0f 92       	push	r0
 10a:	2f 93       	push	r18
 10c:	3f 93       	push	r19
 10e:	4f 93       	push	r20
 110:	5f 93       	push	r21
 112:	6f 93       	push	r22
 114:	7f 93       	push	r23
 116:	8f 93       	push	r24
 118:	9f 93       	push	r25
 11a:	af 93       	push	r26
 11c:	bf 93       	push	r27
 11e:	cf 93       	push	r28
 120:	df 93       	push	r29
 122:	ef 93       	push	r30
 124:	ff 93       	push	r31
	uint16_t ReadValue = 0;
	ReadValue = ADCL;
 126:	c0 91 78 00 	lds	r28, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
	ReadValue = ReadValue | (ADCH << 8);
 12a:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 12e:	d0 e0       	ldi	r29, 0x00	; 0
 130:	d8 2b       	or	r29, r24
	
	ADCValue[ADMUX & 0b00000011] = ReadValue;
 132:	e0 91 7c 00 	lds	r30, 0x007C	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
 136:	e3 70       	andi	r30, 0x03	; 3
 138:	f0 e0       	ldi	r31, 0x00	; 0
 13a:	ee 0f       	add	r30, r30
 13c:	ff 1f       	adc	r31, r31
 13e:	e0 50       	subi	r30, 0x00	; 0
 140:	ff 4f       	sbci	r31, 0xFF	; 255
 142:	d1 83       	std	Z+1, r29	; 0x01
 144:	c0 83       	st	Z, r28
	
	//USARTWriteChar((i & 0xFF00) >> 8);
	//USARTWriteChar(i & 0x00FF);
	USARTWriteChar(ReadValue >> 8);
 146:	8d 2f       	mov	r24, r29
 148:	3f d4       	rcall	.+2174   	; 0x9c8 <USARTWriteChar>
	USARTWriteChar(ReadValue);
 14a:	8c 2f       	mov	r24, r28
 14c:	3d d4       	rcall	.+2170   	; 0x9c8 <USARTWriteChar>
}
 14e:	ff 91       	pop	r31
 150:	ef 91       	pop	r30
 152:	df 91       	pop	r29
 154:	cf 91       	pop	r28
 156:	bf 91       	pop	r27
 158:	af 91       	pop	r26
 15a:	9f 91       	pop	r25
 15c:	8f 91       	pop	r24
 15e:	7f 91       	pop	r23
 160:	6f 91       	pop	r22
 162:	5f 91       	pop	r21
 164:	4f 91       	pop	r20
 166:	3f 91       	pop	r19
 168:	2f 91       	pop	r18
 16a:	0f 90       	pop	r0
 16c:	0b be       	out	0x3b, r0	; 59
 16e:	0f 90       	pop	r0
 170:	0f be       	out	0x3f, r0	; 63
 172:	0f 90       	pop	r0
 174:	1f 90       	pop	r1
 176:	18 95       	reti

00000178 <can_init>:
}



//***** CAN ialization *****************************************************
void can_init(uint16_t Baud){
 178:	cf 93       	push	r28
 17a:	df 93       	push	r29

	CANGCON = ( 1 << SWRES );   // Software reset
 17c:	21 e0       	ldi	r18, 0x01	; 1
 17e:	20 93 d8 00 	sts	0x00D8, r18	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
	
	CANTCON = 0x00;         // CAN timing prescaler set to 0;
 182:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>
	
	if (Baud == 500){
 186:	84 3f       	cpi	r24, 0xF4	; 244
 188:	21 e0       	ldi	r18, 0x01	; 1
 18a:	92 07       	cpc	r25, r18
 18c:	51 f4       	brne	.+20     	; 0x1a2 <can_init+0x2a>
		CANBT1 = 0x02;      	// Set baud rate to 500kb (assuming 16Mhz IOclk)
 18e:	82 e0       	ldi	r24, 0x02	; 2
 190:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
		CANBT2 = 0x0C;          // "
 194:	8c e0       	ldi	r24, 0x0C	; 12
 196:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
		CANBT3 = 0x37; 			// ""
 19a:	87 e3       	ldi	r24, 0x37	; 55
 19c:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
 1a0:	19 c0       	rjmp	.+50     	; 0x1d4 <can_init+0x5c>
	}
	if (Baud == 250){
 1a2:	8a 3f       	cpi	r24, 0xFA	; 250
 1a4:	91 05       	cpc	r25, r1
 1a6:	51 f4       	brne	.+20     	; 0x1bc <can_init+0x44>
		CANBT1 = 0x0E;      	// Set baud rate to 250kb (assuming 16Mhz IOclk)
 1a8:	8e e0       	ldi	r24, 0x0E	; 14
 1aa:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
		CANBT2 = 0x04;          // "
 1ae:	84 e0       	ldi	r24, 0x04	; 4
 1b0:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
		CANBT3 = 0x13; 			// ""
 1b4:	83 e1       	ldi	r24, 0x13	; 19
 1b6:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
 1ba:	0c c0       	rjmp	.+24     	; 0x1d4 <can_init+0x5c>
	}
	if ( Baud == 125){
 1bc:	8d 37       	cpi	r24, 0x7D	; 125
 1be:	91 05       	cpc	r25, r1
 1c0:	49 f4       	brne	.+18     	; 0x1d4 <can_init+0x5c>
		CANBT1 = 0x06;      	// Set baud rate to 250kb (assuming 16Mhz IOclk)
 1c2:	86 e0       	ldi	r24, 0x06	; 6
 1c4:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
		CANBT2 = 0x0C;          // "
 1c8:	8c e0       	ldi	r24, 0x0C	; 12
 1ca:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
		CANBT3 = 0x37; 			// ""
 1ce:	87 e3       	ldi	r24, 0x37	; 55
 1d0:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
}



//***** CAN ialization *****************************************************
void can_init(uint16_t Baud){
 1d4:	80 e0       	ldi	r24, 0x00	; 0
	}
	

	for ( int8_t mob=0; mob<14; mob++ ) {

		CANPAGE = ( mob << 4 );     	// Selects Message Object 0-14
 1d6:	cd ee       	ldi	r28, 0xED	; 237
 1d8:	d0 e0       	ldi	r29, 0x00	; 0
		CANCDMOB = 0x00;       		// Disable mob
 1da:	af ee       	ldi	r26, 0xEF	; 239
 1dc:	b0 e0       	ldi	r27, 0x00	; 0
		CANSTMOB = 0x00;     		// Clear mob status register;
 1de:	ee ee       	ldi	r30, 0xEE	; 238
 1e0:	f0 e0       	ldi	r31, 0x00	; 0
	}
	

	for ( int8_t mob=0; mob<14; mob++ ) {

		CANPAGE = ( mob << 4 );     	// Selects Message Object 0-14
 1e2:	98 2f       	mov	r25, r24
 1e4:	92 95       	swap	r25
 1e6:	90 7f       	andi	r25, 0xF0	; 240
 1e8:	98 83       	st	Y, r25
		CANCDMOB = 0x00;       		// Disable mob
 1ea:	1c 92       	st	X, r1
		CANSTMOB = 0x00;     		// Clear mob status register;
 1ec:	10 82       	st	Z, r1
 1ee:	8f 5f       	subi	r24, 0xFF	; 255
		CANBT2 = 0x0C;          // "
		CANBT3 = 0x37; 			// ""
	}
	

	for ( int8_t mob=0; mob<14; mob++ ) {
 1f0:	8e 30       	cpi	r24, 0x0E	; 14
 1f2:	b9 f7       	brne	.-18     	; 0x1e2 <can_init+0x6a>
		CANPAGE = ( mob << 4 );     	// Selects Message Object 0-14
		CANCDMOB = 0x00;       		// Disable mob
		CANSTMOB = 0x00;     		// Clear mob status register;
	}
	
	CANIE2 = (( 1 << IEMOB1 ) | ( 0 << IEMOB0 ));   	// IEMOB1 = MOB1 Enable interrupts on mob1 for reception and transmission
 1f4:	82 e0       	ldi	r24, 0x02	; 2
 1f6:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	CANGIE = ( 1 << ENIT ) | ( 1 << ENRX ) | ( 0 << ENTX );   // Enable interrupts on receive
 1fa:	80 ea       	ldi	r24, 0xA0	; 160
 1fc:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>
	CANGCON |= ( 1 << 1 );		// ENASTB = 1	// Enable mode. CAN channel enters in enable mode once 11 recessive bits have been read
 200:	e8 ed       	ldi	r30, 0xD8	; 216
 202:	f0 e0       	ldi	r31, 0x00	; 0
 204:	80 81       	ld	r24, Z
 206:	82 60       	ori	r24, 0x02	; 2
 208:	80 83       	st	Z, r24
	
}
 20a:	df 91       	pop	r29
 20c:	cf 91       	pop	r28
 20e:	08 95       	ret

00000210 <can_rx>:

//***** CAN Creating RX *****************************************************
void can_rx(uint16_t NODE_ID){
	
	CANPAGE = ( 0 << MOBNB3 ) | ( 0 << MOBNB2 ) | ( 0 << MOBNB1 ) | ( 1 << MOBNB0 ); // select 0001 = MOB1
 210:	20 e1       	ldi	r18, 0x10	; 16
 212:	20 93 ed 00 	sts	0x00ED, r18	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	
	CANIDT1 = NODE_ID >> 3;   	// Ontvangst adress
 216:	9c 01       	movw	r18, r24
 218:	36 95       	lsr	r19
 21a:	27 95       	ror	r18
 21c:	36 95       	lsr	r19
 21e:	27 95       	ror	r18
 220:	36 95       	lsr	r19
 222:	27 95       	ror	r18
 224:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
	CANIDT2 = NODE_ID << 5;		//
 228:	82 95       	swap	r24
 22a:	88 0f       	add	r24, r24
 22c:	80 7e       	andi	r24, 0xE0	; 224
 22e:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT3 = 0x00; 			// ""
 232:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
	CANIDT4 = 0x00; 			// ""
 236:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	
	CANIDM1 = 0b11111111;   // Ontvangst adress
 23a:	8f ef       	ldi	r24, 0xFF	; 255
 23c:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	CANIDM2 = 0b11100000;	//
 240:	80 ee       	ldi	r24, 0xE0	; 224
 242:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	//CANIDM1 = 0b00000000;   // Ontvangst adress
	//CANIDM2 = 0b00000000;	//
	
	CANIDM3 = 0b00000000; 	// ""
 246:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
	CANIDM4 = 0b00000000; 	// ""
 24a:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>

	CANCDMOB = (( 1 << CONMOB1 ) | ( 0 << IDE ) | ( 3 << DLC0));  // Enable Reception | 11 bit | IDE DLC8
 24e:	83 e8       	ldi	r24, 0x83	; 131
 250:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
 254:	08 95       	ret

00000256 <can_tx>:

}


//***** CAN Creating TX *****************************************************
void can_tx(uint16_t Adress, uint8_t DLC) {
 256:	9c 01       	movw	r18, r24
	
	CANPAGE = ( 0 << MOBNB3 ) | ( 0 << MOBNB2 ) | ( 0 << MOBNB1 ) | ( 0 << MOBNB0 ); // select 0000 = MOB0
 258:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

	while ( CANEN2 & ( 1 << ENMOB0 ) ); // Wait for MOb 0 to be free
 25c:	ec ed       	ldi	r30, 0xDC	; 220
 25e:	f0 e0       	ldi	r31, 0x00	; 0
 260:	90 81       	ld	r25, Z
 262:	90 fd       	sbrc	r25, 0
 264:	fd cf       	rjmp	.-6      	; 0x260 <can_tx+0xa>
	
	CANSTMOB = 0x00;    		// Clear mob status register
 266:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
	
	CANIDT4 = 0x00;     		//
 26a:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDT3 = 0x00;				//
 26e:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
	CANIDT2 = Adress << 5;		//
 272:	82 2f       	mov	r24, r18
 274:	82 95       	swap	r24
 276:	88 0f       	add	r24, r24
 278:	80 7e       	andi	r24, 0xE0	; 224
 27a:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = Adress >> 3;		//
 27e:	36 95       	lsr	r19
 280:	27 95       	ror	r18
 282:	36 95       	lsr	r19
 284:	27 95       	ror	r18
 286:	36 95       	lsr	r19
 288:	27 95       	ror	r18
 28a:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
 28e:	e8 e0       	ldi	r30, 0x08	; 8
 290:	f1 e0       	ldi	r31, 0x01	; 1
 292:	20 e1       	ldi	r18, 0x10	; 16
 294:	31 e0       	ldi	r19, 0x01	; 1
	
	for ( int8_t i = 0; i < 8; i++ ){
		CANMSG = TransmitData[i];
 296:	aa ef       	ldi	r26, 0xFA	; 250
 298:	b0 e0       	ldi	r27, 0x00	; 0
 29a:	81 91       	ld	r24, Z+
 29c:	8c 93       	st	X, r24
	CANIDT4 = 0x00;     		//
	CANIDT3 = 0x00;				//
	CANIDT2 = Adress << 5;		//
	CANIDT1 = Adress >> 3;		//
	
	for ( int8_t i = 0; i < 8; i++ ){
 29e:	e2 17       	cp	r30, r18
 2a0:	f3 07       	cpc	r31, r19
 2a2:	d9 f7       	brne	.-10     	; 0x29a <can_tx+0x44>
		CANMSG = TransmitData[i];
	}
	
	CANCDMOB = (( 1 << CONMOB0 ) | ( 0 << IDE ) | ( DLC << DLC0));
 2a4:	60 64       	ori	r22, 0x40	; 64
 2a6:	60 93 ef 00 	sts	0x00EF, r22	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	while ( ! ( CANSTMOB & ( 1 << TXOK ) ) );	// wait for TXOK flag set
 2aa:	ee ee       	ldi	r30, 0xEE	; 238
 2ac:	f0 e0       	ldi	r31, 0x00	; 0
 2ae:	80 81       	ld	r24, Z
 2b0:	86 ff       	sbrs	r24, 6
 2b2:	fd cf       	rjmp	.-6      	; 0x2ae <can_tx+0x58>
	
	CANCDMOB = 0x00;
 2b4:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	CANSTMOB = 0x00;	// Clear TXOK flag
 2b8:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
	
	CANPAGE = ( 0 << MOBNB3 ) | ( 0 << MOBNB2 ) | ( 0 << MOBNB1 ) | ( 1 << MOBNB0 ); // select 0001 = MOB1
 2bc:	80 e1       	ldi	r24, 0x10	; 16
 2be:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
 2c2:	08 95       	ret

000002c4 <__vector_18>:

uint8_t ReceiveData[8];
uint8_t TransmitData[8];

//***** Reception ISR **********************************
ISR(CANIT_vect){  					// use interrupts
 2c4:	1f 92       	push	r1
 2c6:	0f 92       	push	r0
 2c8:	0f b6       	in	r0, 0x3f	; 63
 2ca:	0f 92       	push	r0
 2cc:	11 24       	eor	r1, r1
 2ce:	0b b6       	in	r0, 0x3b	; 59
 2d0:	0f 92       	push	r0
 2d2:	cf 92       	push	r12
 2d4:	df 92       	push	r13
 2d6:	ef 92       	push	r14
 2d8:	ff 92       	push	r15
 2da:	0f 93       	push	r16
 2dc:	1f 93       	push	r17
 2de:	2f 93       	push	r18
 2e0:	3f 93       	push	r19
 2e2:	4f 93       	push	r20
 2e4:	5f 93       	push	r21
 2e6:	6f 93       	push	r22
 2e8:	7f 93       	push	r23
 2ea:	8f 93       	push	r24
 2ec:	9f 93       	push	r25
 2ee:	af 93       	push	r26
 2f0:	bf 93       	push	r27
 2f2:	cf 93       	push	r28
 2f4:	df 93       	push	r29
 2f6:	ef 93       	push	r30
 2f8:	ff 93       	push	r31
	PORTE &= ~(1 << PE4);
 2fa:	74 98       	cbi	0x0e, 4	; 14

	int8_t length;
	
	CANPAGE = ( 0 << MOBNB3 ) | ( 0 << MOBNB2 ) | ( 0 << MOBNB1 ) | ( 1 << MOBNB0 ); // select CANMOB 0001 = MOB1
 2fc:	80 e1       	ldi	r24, 0x10	; 16
 2fe:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

	length = ( CANCDMOB & 0x0F );	// DLC, number of bytes to be received
 302:	d0 91 ef 00 	lds	r29, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
 306:	df 70       	andi	r29, 0x0F	; 15
	for ( int8_t i = 0; i < length; i++ ){
 308:	1d 16       	cp	r1, r29
 30a:	74 f4       	brge	.+28     	; 0x328 <__vector_18+0x64>
 30c:	e0 e1       	ldi	r30, 0x10	; 16
 30e:	f1 e0       	ldi	r31, 0x01	; 1
 310:	2f ef       	ldi	r18, 0xFF	; 255
 312:	2d 0f       	add	r18, r29
 314:	30 e0       	ldi	r19, 0x00	; 0
 316:	2f 5e       	subi	r18, 0xEF	; 239
 318:	3e 4f       	sbci	r19, 0xFE	; 254
		ReceiveData[i] = CANMSG; 		// Get data, INDX auto increments CANMSG
 31a:	aa ef       	ldi	r26, 0xFA	; 250
 31c:	b0 e0       	ldi	r27, 0x00	; 0
 31e:	8c 91       	ld	r24, X
 320:	81 93       	st	Z+, r24
	int8_t length;
	
	CANPAGE = ( 0 << MOBNB3 ) | ( 0 << MOBNB2 ) | ( 0 << MOBNB1 ) | ( 1 << MOBNB0 ); // select CANMOB 0001 = MOB1

	length = ( CANCDMOB & 0x0F );	// DLC, number of bytes to be received
	for ( int8_t i = 0; i < length; i++ ){
 322:	e2 17       	cp	r30, r18
 324:	f3 07       	cpc	r31, r19
 326:	d9 f7       	brne	.-10     	; 0x31e <__vector_18+0x5a>
		ReceiveData[i] = CANMSG; 		// Get data, INDX auto increments CANMSG
		//USARTWriteChar(ReceiveData[i]);
	}
	
	uint16_t ReceiveAdress = (CANIDT1 << 3) | ((CANIDT2 & 0b11100000) >> 5);
 328:	00 91 f3 00 	lds	r16, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
 32c:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
 330:	82 95       	swap	r24
 332:	86 95       	lsr	r24
 334:	87 70       	andi	r24, 0x07	; 7
 336:	10 e0       	ldi	r17, 0x00	; 0
 338:	00 0f       	add	r16, r16
 33a:	11 1f       	adc	r17, r17
 33c:	00 0f       	add	r16, r16
 33e:	11 1f       	adc	r17, r17
 340:	00 0f       	add	r16, r16
 342:	11 1f       	adc	r17, r17
 344:	08 2b       	or	r16, r24
	
	//USARTWriteChar((ReceiveAdress & 0xFF00) >> 8);
	//USARTWriteChar(ReceiveAdress & 0x00FF);
	
	if(ReceiveAdress == MASTERID){ //Only receive if adress is the masterID
 346:	07 31       	cpi	r16, 0x17	; 23
 348:	83 e0       	ldi	r24, 0x03	; 3
 34a:	18 07       	cpc	r17, r24
 34c:	09 f0       	breq	.+2      	; 0x350 <__vector_18+0x8c>
 34e:	6f c0       	rjmp	.+222    	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
 350:	62 c0       	rjmp	.+196    	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
		
		for (uint8_t i = 0; i < length; i = i ){
			if ((ReceiveData[i] & 0b00111111) == 0x01){
 352:	f6 01       	movw	r30, r12
 354:	e0 5f       	subi	r30, 0xF0	; 240
 356:	fe 4f       	sbci	r31, 0xFE	; 254
 358:	80 81       	ld	r24, Z
 35a:	8f 73       	andi	r24, 0x3F	; 63
 35c:	81 30       	cpi	r24, 0x01	; 1
 35e:	79 f4       	brne	.+30     	; 0x37e <__vector_18+0xba>
				USARTWriteChar(ReceiveData[i] & 0b00111111);
 360:	33 d3       	rcall	.+1638   	; 0x9c8 <USARTWriteChar>
				USARTWriteChar((ReceiveData[i] & 0b11000000) >> 6);
 362:	f6 01       	movw	r30, r12
 364:	e0 5f       	subi	r30, 0xF0	; 240
 366:	fe 4f       	sbci	r31, 0xFE	; 254
 368:	6f 01       	movw	r12, r30
 36a:	80 81       	ld	r24, Z
 36c:	82 95       	swap	r24
 36e:	86 95       	lsr	r24
 370:	86 95       	lsr	r24
 372:	83 70       	andi	r24, 0x03	; 3
 374:	29 d3       	rcall	.+1618   	; 0x9c8 <USARTWriteChar>
				USARTWriteChar(ReceiveData[i + 1]);
 376:	f6 01       	movw	r30, r12
 378:	81 81       	ldd	r24, Z+1	; 0x01
 37a:	26 d3       	rcall	.+1612   	; 0x9c8 <USARTWriteChar>
				i += 2;
 37c:	ce 5f       	subi	r28, 0xFE	; 254
			}
			if ((ReceiveData[i] & 0b00111111) == 0x02){
 37e:	cc 2e       	mov	r12, r28
 380:	d1 2c       	mov	r13, r1
 382:	f6 01       	movw	r30, r12
 384:	e0 5f       	subi	r30, 0xF0	; 240
 386:	fe 4f       	sbci	r31, 0xFE	; 254
 388:	80 81       	ld	r24, Z
 38a:	8f 73       	andi	r24, 0x3F	; 63
 38c:	82 30       	cpi	r24, 0x02	; 2
 38e:	81 f4       	brne	.+32     	; 0x3b0 <__vector_18+0xec>
				USARTWriteChar(ReceiveData[i] & 0b00111111);
 390:	1b d3       	rcall	.+1590   	; 0x9c8 <USARTWriteChar>
				USARTWriteChar((ReceiveData[i] & 0b11000000) >> 6);
 392:	c6 01       	movw	r24, r12
 394:	80 5f       	subi	r24, 0xF0	; 240
 396:	9e 4f       	sbci	r25, 0xFE	; 254
 398:	6c 01       	movw	r12, r24
 39a:	fc 01       	movw	r30, r24
 39c:	80 81       	ld	r24, Z
 39e:	82 95       	swap	r24
 3a0:	86 95       	lsr	r24
 3a2:	86 95       	lsr	r24
 3a4:	83 70       	andi	r24, 0x03	; 3
 3a6:	10 d3       	rcall	.+1568   	; 0x9c8 <USARTWriteChar>
				USARTWriteChar(ReceiveData[i + 1]);
 3a8:	f6 01       	movw	r30, r12
 3aa:	81 81       	ldd	r24, Z+1	; 0x01
 3ac:	0d d3       	rcall	.+1562   	; 0x9c8 <USARTWriteChar>
				i += 2;
 3ae:	ce 5f       	subi	r28, 0xFE	; 254
			}
			if ((ReceiveData[i] & 0b00111111) == 0x03){
 3b0:	cc 2e       	mov	r12, r28
 3b2:	d1 2c       	mov	r13, r1
 3b4:	f6 01       	movw	r30, r12
 3b6:	e0 5f       	subi	r30, 0xF0	; 240
 3b8:	fe 4f       	sbci	r31, 0xFE	; 254
 3ba:	80 81       	ld	r24, Z
 3bc:	8f 73       	andi	r24, 0x3F	; 63
 3be:	83 30       	cpi	r24, 0x03	; 3
 3c0:	81 f4       	brne	.+32     	; 0x3e2 <__vector_18+0x11e>
				USARTWriteChar(ReceiveData[i] & 0b00111111);
 3c2:	02 d3       	rcall	.+1540   	; 0x9c8 <USARTWriteChar>
				USARTWriteChar((ReceiveData[i] & 0b11000000) >> 6);
 3c4:	c6 01       	movw	r24, r12
 3c6:	80 5f       	subi	r24, 0xF0	; 240
 3c8:	9e 4f       	sbci	r25, 0xFE	; 254
 3ca:	6c 01       	movw	r12, r24
 3cc:	fc 01       	movw	r30, r24
 3ce:	80 81       	ld	r24, Z
 3d0:	82 95       	swap	r24
 3d2:	86 95       	lsr	r24
 3d4:	86 95       	lsr	r24
 3d6:	83 70       	andi	r24, 0x03	; 3
 3d8:	f7 d2       	rcall	.+1518   	; 0x9c8 <USARTWriteChar>
				USARTWriteChar(ReceiveData[i + 1]);
 3da:	f6 01       	movw	r30, r12
 3dc:	81 81       	ldd	r24, Z+1	; 0x01
 3de:	f4 d2       	rcall	.+1512   	; 0x9c8 <USARTWriteChar>
				i += 2;
 3e0:	ce 5f       	subi	r28, 0xFE	; 254
			}
			if ((ReceiveData[i] & 0b00111111) == 0x04){
 3e2:	cc 2e       	mov	r12, r28
 3e4:	d1 2c       	mov	r13, r1
 3e6:	f6 01       	movw	r30, r12
 3e8:	e0 5f       	subi	r30, 0xF0	; 240
 3ea:	fe 4f       	sbci	r31, 0xFE	; 254
 3ec:	80 81       	ld	r24, Z
 3ee:	8f 73       	andi	r24, 0x3F	; 63
 3f0:	84 30       	cpi	r24, 0x04	; 4
 3f2:	b1 f4       	brne	.+44     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
				USARTWriteChar(ReceiveData[i] & 0b00111111);
 3f4:	e9 d2       	rcall	.+1490   	; 0x9c8 <USARTWriteChar>
				USARTWriteChar((ReceiveData[i] & 0b11000000) >> 6);
 3f6:	c6 01       	movw	r24, r12
 3f8:	80 5f       	subi	r24, 0xF0	; 240
 3fa:	9e 4f       	sbci	r25, 0xFE	; 254
 3fc:	6c 01       	movw	r12, r24
 3fe:	fc 01       	movw	r30, r24
 400:	80 81       	ld	r24, Z
 402:	82 95       	swap	r24
 404:	86 95       	lsr	r24
 406:	86 95       	lsr	r24
 408:	83 70       	andi	r24, 0x03	; 3
 40a:	de d2       	rcall	.+1468   	; 0x9c8 <USARTWriteChar>
				USARTWriteChar(ReceiveData[i + 1]);
 40c:	f6 01       	movw	r30, r12
 40e:	81 81       	ldd	r24, Z+1	; 0x01
 410:	db d2       	rcall	.+1462   	; 0x9c8 <USARTWriteChar>
				i += 2;
 412:	ce 5f       	subi	r28, 0xFE	; 254
 414:	05 c0       	rjmp	.+10     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
 416:	c0 e0       	ldi	r28, 0x00	; 0
	//USARTWriteChar((ReceiveAdress & 0xFF00) >> 8);
	//USARTWriteChar(ReceiveAdress & 0x00FF);
	
	if(ReceiveAdress == MASTERID){ //Only receive if adress is the masterID
		
		for (uint8_t i = 0; i < length; i = i ){
 418:	ed 2e       	mov	r14, r29
 41a:	0d 2e       	mov	r0, r29
 41c:	00 0c       	add	r0, r0
 41e:	ff 08       	sbc	r15, r15
 420:	cc 2e       	mov	r12, r28
 422:	d1 2c       	mov	r13, r1
 424:	ce 14       	cp	r12, r14
 426:	df 04       	cpc	r13, r15
 428:	0c f4       	brge	.+2      	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
 42a:	93 cf       	rjmp	.-218    	; 0x352 <__vector_18+0x8e>
 42c:	23 c1       	rjmp	.+582    	; 0x674 <__LOCK_REGION_LENGTH__+0x274>
			}
		}
	}
	
	
	if(ReceiveAdress == NODEID1){
 42e:	01 30       	cpi	r16, 0x01	; 1
 430:	f2 e0       	ldi	r31, 0x02	; 2
 432:	1f 07       	cpc	r17, r31
 434:	09 f0       	breq	.+2      	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
 436:	8d c0       	rjmp	.+282    	; 0x552 <__LOCK_REGION_LENGTH__+0x152>
		if (ReceiveData[0] == 0x3D) {
 438:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <ReceiveData>
 43c:	8d 33       	cpi	r24, 0x3D	; 61
 43e:	09 f0       	breq	.+2      	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
 440:	86 c0       	rjmp	.+268    	; 0x54e <__LOCK_REGION_LENGTH__+0x14e>
			PORTE &= ~(1<<PE4);
 442:	74 98       	cbi	0x0e, 4	; 14
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
 444:	4d 2f       	mov	r20, r29
 446:	0d 2e       	mov	r0, r29
 448:	00 0c       	add	r0, r0
 44a:	55 0b       	sbc	r21, r21
 44c:	42 30       	cpi	r20, 0x02	; 2
 44e:	51 05       	cpc	r21, r1
 450:	0c f4       	brge	.+2      	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
 452:	78 c0       	rjmp	.+240    	; 0x544 <__LOCK_REGION_LENGTH__+0x144>
				if (ReceiveData[i] == 0x01){
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[0];
				}
				if (ReceiveData[i] == 0x02){
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
 454:	e0 e0       	ldi	r30, 0x00	; 0
 456:	f1 e0       	ldi	r31, 0x01	; 1
 458:	22 81       	ldd	r18, Z+2	; 0x02
 45a:	33 81       	ldd	r19, Z+3	; 0x03
 45c:	c9 01       	movw	r24, r18
 45e:	96 95       	lsr	r25
 460:	87 95       	ror	r24
 462:	96 95       	lsr	r25
 464:	87 95       	ror	r24
 466:	b8 2f       	mov	r27, r24
 468:	b0 7c       	andi	r27, 0xC0	; 192
 46a:	b2 60       	ori	r27, 0x02	; 2
					TransmitData[j++]		= ADCValue[1];
 46c:	d2 2e       	mov	r13, r18
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
				if (ReceiveData[i] == 0x01){
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
 46e:	e0 80       	ld	r14, Z
 470:	f1 80       	ldd	r15, Z+1	; 0x01
 472:	c7 01       	movw	r24, r14
 474:	96 95       	lsr	r25
 476:	87 95       	ror	r24
 478:	96 95       	lsr	r25
 47a:	87 95       	ror	r24
 47c:	a8 2f       	mov	r26, r24
 47e:	a0 7c       	andi	r26, 0xC0	; 192
 480:	a1 60       	ori	r26, 0x01	; 1
				if (ReceiveData[i] == 0x02){
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[1];
				}
				if (ReceiveData[i] == 0x03){
					TransmitData[j++] = 0x03 | ((ADCValue[2] >> 2) & 0b11000000 ) ;
 482:	24 81       	ldd	r18, Z+4	; 0x04
 484:	35 81       	ldd	r19, Z+5	; 0x05
 486:	c9 01       	movw	r24, r18
 488:	96 95       	lsr	r25
 48a:	87 95       	ror	r24
 48c:	96 95       	lsr	r25
 48e:	87 95       	ror	r24
 490:	78 2f       	mov	r23, r24
 492:	70 7c       	andi	r23, 0xC0	; 192
 494:	73 60       	ori	r23, 0x03	; 3
					TransmitData[j++]		= ADCValue[2];
 496:	f2 2e       	mov	r15, r18
				}
				if (ReceiveData[i] == 0x04){
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
 498:	26 81       	ldd	r18, Z+6	; 0x06
 49a:	37 81       	ldd	r19, Z+7	; 0x07
 49c:	c9 01       	movw	r24, r18
 49e:	96 95       	lsr	r25
 4a0:	87 95       	ror	r24
 4a2:	96 95       	lsr	r25
 4a4:	87 95       	ror	r24
 4a6:	38 2f       	mov	r19, r24
 4a8:	30 7c       	andi	r19, 0xC0	; 192
 4aa:	34 60       	ori	r19, 0x04	; 4
					TransmitData[j++]		= ADCValue[3];
 4ac:	c2 2f       	mov	r28, r18
 4ae:	81 e0       	ldi	r24, 0x01	; 1
 4b0:	90 e0       	ldi	r25, 0x00	; 0
 4b2:	21 e0       	ldi	r18, 0x01	; 1
 4b4:	60 e0       	ldi	r22, 0x00	; 0
	if(ReceiveAdress == NODEID1){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
				if (ReceiveData[i] == 0x01){
 4b6:	fc 01       	movw	r30, r24
 4b8:	e0 5f       	subi	r30, 0xF0	; 240
 4ba:	fe 4f       	sbci	r31, 0xFE	; 254
 4bc:	80 81       	ld	r24, Z
 4be:	81 30       	cpi	r24, 0x01	; 1
 4c0:	69 f4       	brne	.+26     	; 0x4dc <__LOCK_REGION_LENGTH__+0xdc>
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
 4c2:	e6 2f       	mov	r30, r22
 4c4:	f0 e0       	ldi	r31, 0x00	; 0
 4c6:	e8 5f       	subi	r30, 0xF8	; 248
 4c8:	fe 4f       	sbci	r31, 0xFE	; 254
 4ca:	a0 83       	st	Z, r26
					TransmitData[j++]		= ADCValue[0];
 4cc:	e1 e0       	ldi	r30, 0x01	; 1
 4ce:	e6 0f       	add	r30, r22
 4d0:	f0 e0       	ldi	r31, 0x00	; 0
 4d2:	6e 5f       	subi	r22, 0xFE	; 254
 4d4:	e8 5f       	subi	r30, 0xF8	; 248
 4d6:	fe 4f       	sbci	r31, 0xFE	; 254
 4d8:	e0 82       	st	Z, r14
 4da:	1e c0       	rjmp	.+60     	; 0x518 <__LOCK_REGION_LENGTH__+0x118>
				}
				if (ReceiveData[i] == 0x02){
 4dc:	82 30       	cpi	r24, 0x02	; 2
 4de:	69 f4       	brne	.+26     	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
 4e0:	e6 2f       	mov	r30, r22
 4e2:	f0 e0       	ldi	r31, 0x00	; 0
 4e4:	e8 5f       	subi	r30, 0xF8	; 248
 4e6:	fe 4f       	sbci	r31, 0xFE	; 254
 4e8:	b0 83       	st	Z, r27
					TransmitData[j++]		= ADCValue[1];
 4ea:	e1 e0       	ldi	r30, 0x01	; 1
 4ec:	e6 0f       	add	r30, r22
 4ee:	f0 e0       	ldi	r31, 0x00	; 0
 4f0:	6e 5f       	subi	r22, 0xFE	; 254
 4f2:	e8 5f       	subi	r30, 0xF8	; 248
 4f4:	fe 4f       	sbci	r31, 0xFE	; 254
 4f6:	d0 82       	st	Z, r13
 4f8:	1d c0       	rjmp	.+58     	; 0x534 <__LOCK_REGION_LENGTH__+0x134>
				}
				if (ReceiveData[i] == 0x03){
 4fa:	83 30       	cpi	r24, 0x03	; 3
 4fc:	69 f4       	brne	.+26     	; 0x518 <__LOCK_REGION_LENGTH__+0x118>
					TransmitData[j++] = 0x03 | ((ADCValue[2] >> 2) & 0b11000000 ) ;
 4fe:	e6 2f       	mov	r30, r22
 500:	f0 e0       	ldi	r31, 0x00	; 0
 502:	e8 5f       	subi	r30, 0xF8	; 248
 504:	fe 4f       	sbci	r31, 0xFE	; 254
 506:	70 83       	st	Z, r23
					TransmitData[j++]		= ADCValue[2];
 508:	e1 e0       	ldi	r30, 0x01	; 1
 50a:	e6 0f       	add	r30, r22
 50c:	f0 e0       	ldi	r31, 0x00	; 0
 50e:	6e 5f       	subi	r22, 0xFE	; 254
 510:	e8 5f       	subi	r30, 0xF8	; 248
 512:	fe 4f       	sbci	r31, 0xFE	; 254
 514:	f0 82       	st	Z, r15
 516:	0e c0       	rjmp	.+28     	; 0x534 <__LOCK_REGION_LENGTH__+0x134>
				}
				if (ReceiveData[i] == 0x04){
 518:	84 30       	cpi	r24, 0x04	; 4
 51a:	61 f4       	brne	.+24     	; 0x534 <__LOCK_REGION_LENGTH__+0x134>
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
 51c:	e6 2f       	mov	r30, r22
 51e:	f0 e0       	ldi	r31, 0x00	; 0
 520:	e8 5f       	subi	r30, 0xF8	; 248
 522:	fe 4f       	sbci	r31, 0xFE	; 254
 524:	30 83       	st	Z, r19
					TransmitData[j++]		= ADCValue[3];
 526:	e1 e0       	ldi	r30, 0x01	; 1
 528:	e6 0f       	add	r30, r22
 52a:	f0 e0       	ldi	r31, 0x00	; 0
 52c:	6e 5f       	subi	r22, 0xFE	; 254
 52e:	e8 5f       	subi	r30, 0xF8	; 248
 530:	fe 4f       	sbci	r31, 0xFE	; 254
 532:	c0 83       	st	Z, r28
	
	if(ReceiveAdress == NODEID1){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
 534:	2f 5f       	subi	r18, 0xFF	; 255
 536:	82 2f       	mov	r24, r18
 538:	90 e0       	ldi	r25, 0x00	; 0
 53a:	84 17       	cp	r24, r20
 53c:	95 07       	cpc	r25, r21
 53e:	0c f4       	brge	.+2      	; 0x542 <__LOCK_REGION_LENGTH__+0x142>
 540:	ba cf       	rjmp	.-140    	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
 542:	01 c0       	rjmp	.+2      	; 0x546 <__LOCK_REGION_LENGTH__+0x146>
	
	
	if(ReceiveAdress == NODEID1){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
 544:	60 e0       	ldi	r22, 0x00	; 0
				if (ReceiveData[i] == 0x04){
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[3];
				}
			}
			can_tx(MASTERID, j);
 546:	87 e1       	ldi	r24, 0x17	; 23
 548:	93 e0       	ldi	r25, 0x03	; 3
 54a:	85 de       	rcall	.-758    	; 0x256 <can_tx>
 54c:	24 c1       	rjmp	.+584    	; 0x796 <__LOCK_REGION_LENGTH__+0x396>
		}
		else{
			PORTE |= (1<<PE4);
 54e:	74 9a       	sbi	0x0e, 4	; 14
 550:	22 c1       	rjmp	.+580    	; 0x796 <__LOCK_REGION_LENGTH__+0x396>
		}
	}
	

	if(ReceiveAdress == NODEID2){
 552:	02 30       	cpi	r16, 0x02	; 2
 554:	82 e0       	ldi	r24, 0x02	; 2
 556:	18 07       	cpc	r17, r24
 558:	09 f0       	breq	.+2      	; 0x55c <__LOCK_REGION_LENGTH__+0x15c>
 55a:	8c c0       	rjmp	.+280    	; 0x674 <__LOCK_REGION_LENGTH__+0x274>
		if (ReceiveData[0] == 0x3D) {
 55c:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <ReceiveData>
 560:	8d 33       	cpi	r24, 0x3D	; 61
 562:	09 f0       	breq	.+2      	; 0x566 <__LOCK_REGION_LENGTH__+0x166>
 564:	85 c0       	rjmp	.+266    	; 0x670 <__LOCK_REGION_LENGTH__+0x270>
			PORTE &= ~(1<<PE4);
 566:	74 98       	cbi	0x0e, 4	; 14
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
 568:	4d 2f       	mov	r20, r29
 56a:	dd 0f       	add	r29, r29
 56c:	55 0b       	sbc	r21, r21
 56e:	42 30       	cpi	r20, 0x02	; 2
 570:	51 05       	cpc	r21, r1
 572:	0c f4       	brge	.+2      	; 0x576 <__LOCK_REGION_LENGTH__+0x176>
 574:	78 c0       	rjmp	.+240    	; 0x666 <__LOCK_REGION_LENGTH__+0x266>
				if (ReceiveData[i] == 0x01){
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[0];
				}
				if (ReceiveData[i] == 0x02){
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
 576:	e0 e0       	ldi	r30, 0x00	; 0
 578:	f1 e0       	ldi	r31, 0x01	; 1
 57a:	02 81       	ldd	r16, Z+2	; 0x02
 57c:	13 81       	ldd	r17, Z+3	; 0x03
 57e:	c8 01       	movw	r24, r16
 580:	96 95       	lsr	r25
 582:	87 95       	ror	r24
 584:	96 95       	lsr	r25
 586:	87 95       	ror	r24
 588:	b8 2f       	mov	r27, r24
 58a:	b0 7c       	andi	r27, 0xC0	; 192
 58c:	b2 60       	ori	r27, 0x02	; 2
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
				if (ReceiveData[i] == 0x01){
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
 58e:	20 81       	ld	r18, Z
 590:	31 81       	ldd	r19, Z+1	; 0x01
 592:	c9 01       	movw	r24, r18
 594:	96 95       	lsr	r25
 596:	87 95       	ror	r24
 598:	96 95       	lsr	r25
 59a:	87 95       	ror	r24
 59c:	a8 2f       	mov	r26, r24
 59e:	a0 7c       	andi	r26, 0xC0	; 192
 5a0:	a1 60       	ori	r26, 0x01	; 1
					TransmitData[j++]		= ADCValue[0];
 5a2:	12 2f       	mov	r17, r18
				if (ReceiveData[i] == 0x02){
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[1];
				}
				if (ReceiveData[i] == 0x03){
					TransmitData[j++] = 0x03 | ((ADCValue[2] >> 2) & 0b11000000 ) ;
 5a4:	24 81       	ldd	r18, Z+4	; 0x04
 5a6:	35 81       	ldd	r19, Z+5	; 0x05
 5a8:	c9 01       	movw	r24, r18
 5aa:	96 95       	lsr	r25
 5ac:	87 95       	ror	r24
 5ae:	96 95       	lsr	r25
 5b0:	87 95       	ror	r24
 5b2:	78 2f       	mov	r23, r24
 5b4:	70 7c       	andi	r23, 0xC0	; 192
 5b6:	73 60       	ori	r23, 0x03	; 3
					TransmitData[j++]		= ADCValue[2];
 5b8:	d2 2f       	mov	r29, r18
				}
				if (ReceiveData[i] == 0x04){
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
 5ba:	26 81       	ldd	r18, Z+6	; 0x06
 5bc:	37 81       	ldd	r19, Z+7	; 0x07
 5be:	c9 01       	movw	r24, r18
 5c0:	96 95       	lsr	r25
 5c2:	87 95       	ror	r24
 5c4:	96 95       	lsr	r25
 5c6:	87 95       	ror	r24
 5c8:	38 2f       	mov	r19, r24
 5ca:	30 7c       	andi	r19, 0xC0	; 192
 5cc:	34 60       	ori	r19, 0x04	; 4
					TransmitData[j++]		= ADCValue[3];
 5ce:	c2 2f       	mov	r28, r18
 5d0:	81 e0       	ldi	r24, 0x01	; 1
 5d2:	90 e0       	ldi	r25, 0x00	; 0
 5d4:	21 e0       	ldi	r18, 0x01	; 1
 5d6:	60 e0       	ldi	r22, 0x00	; 0
	if(ReceiveAdress == NODEID2){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
				if (ReceiveData[i] == 0x01){
 5d8:	fc 01       	movw	r30, r24
 5da:	e0 5f       	subi	r30, 0xF0	; 240
 5dc:	fe 4f       	sbci	r31, 0xFE	; 254
 5de:	80 81       	ld	r24, Z
 5e0:	81 30       	cpi	r24, 0x01	; 1
 5e2:	69 f4       	brne	.+26     	; 0x5fe <__LOCK_REGION_LENGTH__+0x1fe>
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
 5e4:	e6 2f       	mov	r30, r22
 5e6:	f0 e0       	ldi	r31, 0x00	; 0
 5e8:	e8 5f       	subi	r30, 0xF8	; 248
 5ea:	fe 4f       	sbci	r31, 0xFE	; 254
 5ec:	a0 83       	st	Z, r26
					TransmitData[j++]		= ADCValue[0];
 5ee:	e1 e0       	ldi	r30, 0x01	; 1
 5f0:	e6 0f       	add	r30, r22
 5f2:	f0 e0       	ldi	r31, 0x00	; 0
 5f4:	6e 5f       	subi	r22, 0xFE	; 254
 5f6:	e8 5f       	subi	r30, 0xF8	; 248
 5f8:	fe 4f       	sbci	r31, 0xFE	; 254
 5fa:	10 83       	st	Z, r17
 5fc:	1e c0       	rjmp	.+60     	; 0x63a <__LOCK_REGION_LENGTH__+0x23a>
				}
				if (ReceiveData[i] == 0x02){
 5fe:	82 30       	cpi	r24, 0x02	; 2
 600:	69 f4       	brne	.+26     	; 0x61c <__LOCK_REGION_LENGTH__+0x21c>
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
 602:	e6 2f       	mov	r30, r22
 604:	f0 e0       	ldi	r31, 0x00	; 0
 606:	e8 5f       	subi	r30, 0xF8	; 248
 608:	fe 4f       	sbci	r31, 0xFE	; 254
 60a:	b0 83       	st	Z, r27
					TransmitData[j++]		= ADCValue[1];
 60c:	e1 e0       	ldi	r30, 0x01	; 1
 60e:	e6 0f       	add	r30, r22
 610:	f0 e0       	ldi	r31, 0x00	; 0
 612:	6e 5f       	subi	r22, 0xFE	; 254
 614:	e8 5f       	subi	r30, 0xF8	; 248
 616:	fe 4f       	sbci	r31, 0xFE	; 254
 618:	00 83       	st	Z, r16
 61a:	1d c0       	rjmp	.+58     	; 0x656 <__LOCK_REGION_LENGTH__+0x256>
				}
				if (ReceiveData[i] == 0x03){
 61c:	83 30       	cpi	r24, 0x03	; 3
 61e:	69 f4       	brne	.+26     	; 0x63a <__LOCK_REGION_LENGTH__+0x23a>
					TransmitData[j++] = 0x03 | ((ADCValue[2] >> 2) & 0b11000000 ) ;
 620:	e6 2f       	mov	r30, r22
 622:	f0 e0       	ldi	r31, 0x00	; 0
 624:	e8 5f       	subi	r30, 0xF8	; 248
 626:	fe 4f       	sbci	r31, 0xFE	; 254
 628:	70 83       	st	Z, r23
					TransmitData[j++]		= ADCValue[2];
 62a:	e1 e0       	ldi	r30, 0x01	; 1
 62c:	e6 0f       	add	r30, r22
 62e:	f0 e0       	ldi	r31, 0x00	; 0
 630:	6e 5f       	subi	r22, 0xFE	; 254
 632:	e8 5f       	subi	r30, 0xF8	; 248
 634:	fe 4f       	sbci	r31, 0xFE	; 254
 636:	d0 83       	st	Z, r29
 638:	0e c0       	rjmp	.+28     	; 0x656 <__LOCK_REGION_LENGTH__+0x256>
				}
				if (ReceiveData[i] == 0x04){
 63a:	84 30       	cpi	r24, 0x04	; 4
 63c:	61 f4       	brne	.+24     	; 0x656 <__LOCK_REGION_LENGTH__+0x256>
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
 63e:	e6 2f       	mov	r30, r22
 640:	f0 e0       	ldi	r31, 0x00	; 0
 642:	e8 5f       	subi	r30, 0xF8	; 248
 644:	fe 4f       	sbci	r31, 0xFE	; 254
 646:	30 83       	st	Z, r19
					TransmitData[j++]		= ADCValue[3];
 648:	e1 e0       	ldi	r30, 0x01	; 1
 64a:	e6 0f       	add	r30, r22
 64c:	f0 e0       	ldi	r31, 0x00	; 0
 64e:	6e 5f       	subi	r22, 0xFE	; 254
 650:	e8 5f       	subi	r30, 0xF8	; 248
 652:	fe 4f       	sbci	r31, 0xFE	; 254
 654:	c0 83       	st	Z, r28

	if(ReceiveAdress == NODEID2){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
 656:	2f 5f       	subi	r18, 0xFF	; 255
 658:	82 2f       	mov	r24, r18
 65a:	90 e0       	ldi	r25, 0x00	; 0
 65c:	84 17       	cp	r24, r20
 65e:	95 07       	cpc	r25, r21
 660:	0c f4       	brge	.+2      	; 0x664 <__LOCK_REGION_LENGTH__+0x264>
 662:	ba cf       	rjmp	.-140    	; 0x5d8 <__LOCK_REGION_LENGTH__+0x1d8>
 664:	01 c0       	rjmp	.+2      	; 0x668 <__LOCK_REGION_LENGTH__+0x268>
	

	if(ReceiveAdress == NODEID2){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
 666:	60 e0       	ldi	r22, 0x00	; 0
				if (ReceiveData[i] == 0x04){
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[3];
				}
			}
			can_tx(MASTERID, j);
 668:	87 e1       	ldi	r24, 0x17	; 23
 66a:	93 e0       	ldi	r25, 0x03	; 3
 66c:	f4 dd       	rcall	.-1048   	; 0x256 <can_tx>
 66e:	22 c1       	rjmp	.+580    	; 0x8b4 <__LOCK_REGION_LENGTH__+0x4b4>
		}
		else{
			PORTE |= (1<<PE4);
 670:	74 9a       	sbi	0x0e, 4	; 14
 672:	20 c1       	rjmp	.+576    	; 0x8b4 <__LOCK_REGION_LENGTH__+0x4b4>
		}
	}
	
	if(ReceiveAdress == NODEID3){
 674:	03 30       	cpi	r16, 0x03	; 3
 676:	92 e0       	ldi	r25, 0x02	; 2
 678:	19 07       	cpc	r17, r25
 67a:	09 f0       	breq	.+2      	; 0x67e <__LOCK_REGION_LENGTH__+0x27e>
 67c:	8c c0       	rjmp	.+280    	; 0x796 <__LOCK_REGION_LENGTH__+0x396>
		if (ReceiveData[0] == 0x3D) {
 67e:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <ReceiveData>
 682:	8d 33       	cpi	r24, 0x3D	; 61
 684:	09 f0       	breq	.+2      	; 0x688 <__LOCK_REGION_LENGTH__+0x288>
 686:	85 c0       	rjmp	.+266    	; 0x792 <__LOCK_REGION_LENGTH__+0x392>
			PORTE &= ~(1<<PE4);
 688:	74 98       	cbi	0x0e, 4	; 14
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
 68a:	4d 2f       	mov	r20, r29
 68c:	dd 0f       	add	r29, r29
 68e:	55 0b       	sbc	r21, r21
 690:	42 30       	cpi	r20, 0x02	; 2
 692:	51 05       	cpc	r21, r1
 694:	0c f4       	brge	.+2      	; 0x698 <__LOCK_REGION_LENGTH__+0x298>
 696:	78 c0       	rjmp	.+240    	; 0x788 <__LOCK_REGION_LENGTH__+0x388>
				if (ReceiveData[i] == 0x01){
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[0];
				}
				if (ReceiveData[i] == 0x02){
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
 698:	e0 e0       	ldi	r30, 0x00	; 0
 69a:	f1 e0       	ldi	r31, 0x01	; 1
 69c:	02 81       	ldd	r16, Z+2	; 0x02
 69e:	13 81       	ldd	r17, Z+3	; 0x03
 6a0:	c8 01       	movw	r24, r16
 6a2:	96 95       	lsr	r25
 6a4:	87 95       	ror	r24
 6a6:	96 95       	lsr	r25
 6a8:	87 95       	ror	r24
 6aa:	b8 2f       	mov	r27, r24
 6ac:	b0 7c       	andi	r27, 0xC0	; 192
 6ae:	b2 60       	ori	r27, 0x02	; 2
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
				if (ReceiveData[i] == 0x01){
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
 6b0:	20 81       	ld	r18, Z
 6b2:	31 81       	ldd	r19, Z+1	; 0x01
 6b4:	c9 01       	movw	r24, r18
 6b6:	96 95       	lsr	r25
 6b8:	87 95       	ror	r24
 6ba:	96 95       	lsr	r25
 6bc:	87 95       	ror	r24
 6be:	a8 2f       	mov	r26, r24
 6c0:	a0 7c       	andi	r26, 0xC0	; 192
 6c2:	a1 60       	ori	r26, 0x01	; 1
					TransmitData[j++]		= ADCValue[0];
 6c4:	12 2f       	mov	r17, r18
				if (ReceiveData[i] == 0x02){
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[1];
				}
				if (ReceiveData[i] == 0x03){
					TransmitData[j++] = 0x03 | ((ADCValue[2] >> 2) & 0b11000000 ) ;
 6c6:	24 81       	ldd	r18, Z+4	; 0x04
 6c8:	35 81       	ldd	r19, Z+5	; 0x05
 6ca:	c9 01       	movw	r24, r18
 6cc:	96 95       	lsr	r25
 6ce:	87 95       	ror	r24
 6d0:	96 95       	lsr	r25
 6d2:	87 95       	ror	r24
 6d4:	78 2f       	mov	r23, r24
 6d6:	70 7c       	andi	r23, 0xC0	; 192
 6d8:	73 60       	ori	r23, 0x03	; 3
					TransmitData[j++]		= ADCValue[2];
 6da:	d2 2f       	mov	r29, r18
				}
				if (ReceiveData[i] == 0x04){
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
 6dc:	26 81       	ldd	r18, Z+6	; 0x06
 6de:	37 81       	ldd	r19, Z+7	; 0x07
 6e0:	c9 01       	movw	r24, r18
 6e2:	96 95       	lsr	r25
 6e4:	87 95       	ror	r24
 6e6:	96 95       	lsr	r25
 6e8:	87 95       	ror	r24
 6ea:	38 2f       	mov	r19, r24
 6ec:	30 7c       	andi	r19, 0xC0	; 192
 6ee:	34 60       	ori	r19, 0x04	; 4
					TransmitData[j++]		= ADCValue[3];
 6f0:	c2 2f       	mov	r28, r18
 6f2:	81 e0       	ldi	r24, 0x01	; 1
 6f4:	90 e0       	ldi	r25, 0x00	; 0
 6f6:	21 e0       	ldi	r18, 0x01	; 1
 6f8:	60 e0       	ldi	r22, 0x00	; 0
	if(ReceiveAdress == NODEID3){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
				if (ReceiveData[i] == 0x01){
 6fa:	fc 01       	movw	r30, r24
 6fc:	e0 5f       	subi	r30, 0xF0	; 240
 6fe:	fe 4f       	sbci	r31, 0xFE	; 254
 700:	80 81       	ld	r24, Z
 702:	81 30       	cpi	r24, 0x01	; 1
 704:	69 f4       	brne	.+26     	; 0x720 <__LOCK_REGION_LENGTH__+0x320>
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
 706:	e6 2f       	mov	r30, r22
 708:	f0 e0       	ldi	r31, 0x00	; 0
 70a:	e8 5f       	subi	r30, 0xF8	; 248
 70c:	fe 4f       	sbci	r31, 0xFE	; 254
 70e:	a0 83       	st	Z, r26
					TransmitData[j++]		= ADCValue[0];
 710:	e1 e0       	ldi	r30, 0x01	; 1
 712:	e6 0f       	add	r30, r22
 714:	f0 e0       	ldi	r31, 0x00	; 0
 716:	6e 5f       	subi	r22, 0xFE	; 254
 718:	e8 5f       	subi	r30, 0xF8	; 248
 71a:	fe 4f       	sbci	r31, 0xFE	; 254
 71c:	10 83       	st	Z, r17
 71e:	1e c0       	rjmp	.+60     	; 0x75c <__LOCK_REGION_LENGTH__+0x35c>
				}
				if (ReceiveData[i] == 0x02){
 720:	82 30       	cpi	r24, 0x02	; 2
 722:	69 f4       	brne	.+26     	; 0x73e <__LOCK_REGION_LENGTH__+0x33e>
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
 724:	e6 2f       	mov	r30, r22
 726:	f0 e0       	ldi	r31, 0x00	; 0
 728:	e8 5f       	subi	r30, 0xF8	; 248
 72a:	fe 4f       	sbci	r31, 0xFE	; 254
 72c:	b0 83       	st	Z, r27
					TransmitData[j++]		= ADCValue[1];
 72e:	e1 e0       	ldi	r30, 0x01	; 1
 730:	e6 0f       	add	r30, r22
 732:	f0 e0       	ldi	r31, 0x00	; 0
 734:	6e 5f       	subi	r22, 0xFE	; 254
 736:	e8 5f       	subi	r30, 0xF8	; 248
 738:	fe 4f       	sbci	r31, 0xFE	; 254
 73a:	00 83       	st	Z, r16
 73c:	1d c0       	rjmp	.+58     	; 0x778 <__LOCK_REGION_LENGTH__+0x378>
				}
				if (ReceiveData[i] == 0x03){
 73e:	83 30       	cpi	r24, 0x03	; 3
 740:	69 f4       	brne	.+26     	; 0x75c <__LOCK_REGION_LENGTH__+0x35c>
					TransmitData[j++] = 0x03 | ((ADCValue[2] >> 2) & 0b11000000 ) ;
 742:	e6 2f       	mov	r30, r22
 744:	f0 e0       	ldi	r31, 0x00	; 0
 746:	e8 5f       	subi	r30, 0xF8	; 248
 748:	fe 4f       	sbci	r31, 0xFE	; 254
 74a:	70 83       	st	Z, r23
					TransmitData[j++]		= ADCValue[2];
 74c:	e1 e0       	ldi	r30, 0x01	; 1
 74e:	e6 0f       	add	r30, r22
 750:	f0 e0       	ldi	r31, 0x00	; 0
 752:	6e 5f       	subi	r22, 0xFE	; 254
 754:	e8 5f       	subi	r30, 0xF8	; 248
 756:	fe 4f       	sbci	r31, 0xFE	; 254
 758:	d0 83       	st	Z, r29
 75a:	0e c0       	rjmp	.+28     	; 0x778 <__LOCK_REGION_LENGTH__+0x378>
				}
				if (ReceiveData[i] == 0x04){
 75c:	84 30       	cpi	r24, 0x04	; 4
 75e:	61 f4       	brne	.+24     	; 0x778 <__LOCK_REGION_LENGTH__+0x378>
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
 760:	e6 2f       	mov	r30, r22
 762:	f0 e0       	ldi	r31, 0x00	; 0
 764:	e8 5f       	subi	r30, 0xF8	; 248
 766:	fe 4f       	sbci	r31, 0xFE	; 254
 768:	30 83       	st	Z, r19
					TransmitData[j++]		= ADCValue[3];
 76a:	e1 e0       	ldi	r30, 0x01	; 1
 76c:	e6 0f       	add	r30, r22
 76e:	f0 e0       	ldi	r31, 0x00	; 0
 770:	6e 5f       	subi	r22, 0xFE	; 254
 772:	e8 5f       	subi	r30, 0xF8	; 248
 774:	fe 4f       	sbci	r31, 0xFE	; 254
 776:	c0 83       	st	Z, r28
	
	if(ReceiveAdress == NODEID3){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
 778:	2f 5f       	subi	r18, 0xFF	; 255
 77a:	82 2f       	mov	r24, r18
 77c:	90 e0       	ldi	r25, 0x00	; 0
 77e:	84 17       	cp	r24, r20
 780:	95 07       	cpc	r25, r21
 782:	0c f4       	brge	.+2      	; 0x786 <__LOCK_REGION_LENGTH__+0x386>
 784:	ba cf       	rjmp	.-140    	; 0x6fa <__LOCK_REGION_LENGTH__+0x2fa>
 786:	01 c0       	rjmp	.+2      	; 0x78a <__LOCK_REGION_LENGTH__+0x38a>
	}
	
	if(ReceiveAdress == NODEID3){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
 788:	60 e0       	ldi	r22, 0x00	; 0
				if (ReceiveData[i] == 0x04){
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[3];
				}
			}
			can_tx(MASTERID, j);
 78a:	87 e1       	ldi	r24, 0x17	; 23
 78c:	93 e0       	ldi	r25, 0x03	; 3
 78e:	63 dd       	rcall	.-1338   	; 0x256 <can_tx>
 790:	91 c0       	rjmp	.+290    	; 0x8b4 <__LOCK_REGION_LENGTH__+0x4b4>
		}
		else{
			PORTE |= (1<<PE4);
 792:	74 9a       	sbi	0x0e, 4	; 14
 794:	8f c0       	rjmp	.+286    	; 0x8b4 <__LOCK_REGION_LENGTH__+0x4b4>
		}
	}
	
	if(ReceiveAdress == NODEID4){
 796:	04 30       	cpi	r16, 0x04	; 4
 798:	12 40       	sbci	r17, 0x02	; 2
 79a:	09 f0       	breq	.+2      	; 0x79e <__LOCK_REGION_LENGTH__+0x39e>
 79c:	8b c0       	rjmp	.+278    	; 0x8b4 <__LOCK_REGION_LENGTH__+0x4b4>
		if (ReceiveData[0] == 0x3D) {
 79e:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <ReceiveData>
 7a2:	8d 33       	cpi	r24, 0x3D	; 61
 7a4:	09 f0       	breq	.+2      	; 0x7a8 <__LOCK_REGION_LENGTH__+0x3a8>
 7a6:	85 c0       	rjmp	.+266    	; 0x8b2 <__LOCK_REGION_LENGTH__+0x4b2>
			PORTE &= ~(1<<PE4);
 7a8:	74 98       	cbi	0x0e, 4	; 14
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
 7aa:	4d 2f       	mov	r20, r29
 7ac:	dd 0f       	add	r29, r29
 7ae:	55 0b       	sbc	r21, r21
 7b0:	42 30       	cpi	r20, 0x02	; 2
 7b2:	51 05       	cpc	r21, r1
 7b4:	0c f4       	brge	.+2      	; 0x7b8 <__LOCK_REGION_LENGTH__+0x3b8>
 7b6:	78 c0       	rjmp	.+240    	; 0x8a8 <__LOCK_REGION_LENGTH__+0x4a8>
				if (ReceiveData[i] == 0x01){
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[0];
				}
				if (ReceiveData[i] == 0x02){
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
 7b8:	e0 e0       	ldi	r30, 0x00	; 0
 7ba:	f1 e0       	ldi	r31, 0x01	; 1
 7bc:	02 81       	ldd	r16, Z+2	; 0x02
 7be:	13 81       	ldd	r17, Z+3	; 0x03
 7c0:	c8 01       	movw	r24, r16
 7c2:	96 95       	lsr	r25
 7c4:	87 95       	ror	r24
 7c6:	96 95       	lsr	r25
 7c8:	87 95       	ror	r24
 7ca:	b8 2f       	mov	r27, r24
 7cc:	b0 7c       	andi	r27, 0xC0	; 192
 7ce:	b2 60       	ori	r27, 0x02	; 2
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
				if (ReceiveData[i] == 0x01){
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
 7d0:	20 81       	ld	r18, Z
 7d2:	31 81       	ldd	r19, Z+1	; 0x01
 7d4:	c9 01       	movw	r24, r18
 7d6:	96 95       	lsr	r25
 7d8:	87 95       	ror	r24
 7da:	96 95       	lsr	r25
 7dc:	87 95       	ror	r24
 7de:	a8 2f       	mov	r26, r24
 7e0:	a0 7c       	andi	r26, 0xC0	; 192
 7e2:	a1 60       	ori	r26, 0x01	; 1
					TransmitData[j++]		= ADCValue[0];
 7e4:	12 2f       	mov	r17, r18
				if (ReceiveData[i] == 0x02){
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[1];
				}
				if (ReceiveData[i] == 0x03){
					TransmitData[j++] = 0x03 | ((ADCValue[2] >> 2) & 0b11000000 ) ;
 7e6:	24 81       	ldd	r18, Z+4	; 0x04
 7e8:	35 81       	ldd	r19, Z+5	; 0x05
 7ea:	c9 01       	movw	r24, r18
 7ec:	96 95       	lsr	r25
 7ee:	87 95       	ror	r24
 7f0:	96 95       	lsr	r25
 7f2:	87 95       	ror	r24
 7f4:	78 2f       	mov	r23, r24
 7f6:	70 7c       	andi	r23, 0xC0	; 192
 7f8:	73 60       	ori	r23, 0x03	; 3
					TransmitData[j++]		= ADCValue[2];
 7fa:	d2 2f       	mov	r29, r18
				}
				if (ReceiveData[i] == 0x04){
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
 7fc:	26 81       	ldd	r18, Z+6	; 0x06
 7fe:	37 81       	ldd	r19, Z+7	; 0x07
 800:	c9 01       	movw	r24, r18
 802:	96 95       	lsr	r25
 804:	87 95       	ror	r24
 806:	96 95       	lsr	r25
 808:	87 95       	ror	r24
 80a:	38 2f       	mov	r19, r24
 80c:	30 7c       	andi	r19, 0xC0	; 192
 80e:	34 60       	ori	r19, 0x04	; 4
					TransmitData[j++]		= ADCValue[3];
 810:	c2 2f       	mov	r28, r18
 812:	81 e0       	ldi	r24, 0x01	; 1
 814:	90 e0       	ldi	r25, 0x00	; 0
 816:	21 e0       	ldi	r18, 0x01	; 1
 818:	60 e0       	ldi	r22, 0x00	; 0
	if(ReceiveAdress == NODEID4){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
				if (ReceiveData[i] == 0x01){
 81a:	fc 01       	movw	r30, r24
 81c:	e0 5f       	subi	r30, 0xF0	; 240
 81e:	fe 4f       	sbci	r31, 0xFE	; 254
 820:	80 81       	ld	r24, Z
 822:	81 30       	cpi	r24, 0x01	; 1
 824:	69 f4       	brne	.+26     	; 0x840 <__LOCK_REGION_LENGTH__+0x440>
					TransmitData[j++] = 0x01 | ((ADCValue[0] >> 2) & 0b11000000 ) ;
 826:	e6 2f       	mov	r30, r22
 828:	f0 e0       	ldi	r31, 0x00	; 0
 82a:	e8 5f       	subi	r30, 0xF8	; 248
 82c:	fe 4f       	sbci	r31, 0xFE	; 254
 82e:	a0 83       	st	Z, r26
					TransmitData[j++]		= ADCValue[0];
 830:	e1 e0       	ldi	r30, 0x01	; 1
 832:	e6 0f       	add	r30, r22
 834:	f0 e0       	ldi	r31, 0x00	; 0
 836:	6e 5f       	subi	r22, 0xFE	; 254
 838:	e8 5f       	subi	r30, 0xF8	; 248
 83a:	fe 4f       	sbci	r31, 0xFE	; 254
 83c:	10 83       	st	Z, r17
 83e:	1e c0       	rjmp	.+60     	; 0x87c <__LOCK_REGION_LENGTH__+0x47c>
				}
				if (ReceiveData[i] == 0x02){
 840:	82 30       	cpi	r24, 0x02	; 2
 842:	69 f4       	brne	.+26     	; 0x85e <__LOCK_REGION_LENGTH__+0x45e>
					TransmitData[j++] = 0x02 | ((ADCValue[1] >> 2) & 0b11000000 ) ;
 844:	e6 2f       	mov	r30, r22
 846:	f0 e0       	ldi	r31, 0x00	; 0
 848:	e8 5f       	subi	r30, 0xF8	; 248
 84a:	fe 4f       	sbci	r31, 0xFE	; 254
 84c:	b0 83       	st	Z, r27
					TransmitData[j++]		= ADCValue[1];
 84e:	e1 e0       	ldi	r30, 0x01	; 1
 850:	e6 0f       	add	r30, r22
 852:	f0 e0       	ldi	r31, 0x00	; 0
 854:	6e 5f       	subi	r22, 0xFE	; 254
 856:	e8 5f       	subi	r30, 0xF8	; 248
 858:	fe 4f       	sbci	r31, 0xFE	; 254
 85a:	00 83       	st	Z, r16
 85c:	1d c0       	rjmp	.+58     	; 0x898 <__LOCK_REGION_LENGTH__+0x498>
				}
				if (ReceiveData[i] == 0x03){
 85e:	83 30       	cpi	r24, 0x03	; 3
 860:	69 f4       	brne	.+26     	; 0x87c <__LOCK_REGION_LENGTH__+0x47c>
					TransmitData[j++] = 0x03 | ((ADCValue[2] >> 2) & 0b11000000 ) ;
 862:	e6 2f       	mov	r30, r22
 864:	f0 e0       	ldi	r31, 0x00	; 0
 866:	e8 5f       	subi	r30, 0xF8	; 248
 868:	fe 4f       	sbci	r31, 0xFE	; 254
 86a:	70 83       	st	Z, r23
					TransmitData[j++]		= ADCValue[2];
 86c:	e1 e0       	ldi	r30, 0x01	; 1
 86e:	e6 0f       	add	r30, r22
 870:	f0 e0       	ldi	r31, 0x00	; 0
 872:	6e 5f       	subi	r22, 0xFE	; 254
 874:	e8 5f       	subi	r30, 0xF8	; 248
 876:	fe 4f       	sbci	r31, 0xFE	; 254
 878:	d0 83       	st	Z, r29
 87a:	0e c0       	rjmp	.+28     	; 0x898 <__LOCK_REGION_LENGTH__+0x498>
				}
				if (ReceiveData[i] == 0x04){
 87c:	84 30       	cpi	r24, 0x04	; 4
 87e:	61 f4       	brne	.+24     	; 0x898 <__LOCK_REGION_LENGTH__+0x498>
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
 880:	e6 2f       	mov	r30, r22
 882:	f0 e0       	ldi	r31, 0x00	; 0
 884:	e8 5f       	subi	r30, 0xF8	; 248
 886:	fe 4f       	sbci	r31, 0xFE	; 254
 888:	30 83       	st	Z, r19
					TransmitData[j++]		= ADCValue[3];
 88a:	e1 e0       	ldi	r30, 0x01	; 1
 88c:	e6 0f       	add	r30, r22
 88e:	f0 e0       	ldi	r31, 0x00	; 0
 890:	6e 5f       	subi	r22, 0xFE	; 254
 892:	e8 5f       	subi	r30, 0xF8	; 248
 894:	fe 4f       	sbci	r31, 0xFE	; 254
 896:	c0 83       	st	Z, r28
	
	if(ReceiveAdress == NODEID4){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
			for(uint8_t i = 1; i < length; i++){
 898:	2f 5f       	subi	r18, 0xFF	; 255
 89a:	82 2f       	mov	r24, r18
 89c:	90 e0       	ldi	r25, 0x00	; 0
 89e:	84 17       	cp	r24, r20
 8a0:	95 07       	cpc	r25, r21
 8a2:	0c f4       	brge	.+2      	; 0x8a6 <__LOCK_REGION_LENGTH__+0x4a6>
 8a4:	ba cf       	rjmp	.-140    	; 0x81a <__LOCK_REGION_LENGTH__+0x41a>
 8a6:	01 c0       	rjmp	.+2      	; 0x8aa <__LOCK_REGION_LENGTH__+0x4aa>
	}
	
	if(ReceiveAdress == NODEID4){
		if (ReceiveData[0] == 0x3D) {
			PORTE &= ~(1<<PE4);
			uint8_t j = 0;
 8a8:	60 e0       	ldi	r22, 0x00	; 0
				if (ReceiveData[i] == 0x04){
					TransmitData[j++] = 0x04 | ((ADCValue[3] >> 2) & 0b11000000 ) ;
					TransmitData[j++]		= ADCValue[3];
				}
			}
			can_tx(MASTERID, j);
 8aa:	87 e1       	ldi	r24, 0x17	; 23
 8ac:	93 e0       	ldi	r25, 0x03	; 3
 8ae:	d3 dc       	rcall	.-1626   	; 0x256 <can_tx>
 8b0:	01 c0       	rjmp	.+2      	; 0x8b4 <__LOCK_REGION_LENGTH__+0x4b4>
		}
		else{
			PORTE |= (1<<PE4);
 8b2:	74 9a       	sbi	0x0e, 4	; 14
 8b4:	e0 e1       	ldi	r30, 0x10	; 16
 8b6:	f1 e0       	ldi	r31, 0x01	; 1
 8b8:	a8 e0       	ldi	r26, 0x08	; 8
 8ba:	b1 e0       	ldi	r27, 0x01	; 1
 8bc:	88 e1       	ldi	r24, 0x18	; 24
 8be:	91 e0       	ldi	r25, 0x01	; 1
		}
	}

	for (int8_t i = 0; i < 8; i++){
		ReceiveData[i] = 0;
 8c0:	11 92       	st	Z+, r1
		TransmitData[i] = 0;
 8c2:	1d 92       	st	X+, r1
		else{
			PORTE |= (1<<PE4);
		}
	}

	for (int8_t i = 0; i < 8; i++){
 8c4:	e8 17       	cp	r30, r24
 8c6:	f9 07       	cpc	r31, r25
 8c8:	d9 f7       	brne	.-10     	; 0x8c0 <__LOCK_REGION_LENGTH__+0x4c0>
		ReceiveData[i] = 0;
		TransmitData[i] = 0;
	}


	CANSTMOB = 0x00;
 8ca:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
	CANCDMOB = (( 1 << CONMOB1 ) | ( 0 << IDE ) | ( 3 << DLC0));
 8ce:	83 e8       	ldi	r24, 0x83	; 131
 8d0:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	CANPAGE = ( 0 << MOBNB3 ) | ( 0 << MOBNB2 ) | ( 0 << MOBNB1 ) | ( 0 << MOBNB0 ); // select 0000 = MOB0
 8d4:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

	USARTWriteChar(0xDD);
 8d8:	8d ed       	ldi	r24, 0xDD	; 221
 8da:	76 d0       	rcall	.+236    	; 0x9c8 <USARTWriteChar>
	
	PORTE |= (1 << PE4);
 8dc:	74 9a       	sbi	0x0e, 4	; 14
}
 8de:	ff 91       	pop	r31
 8e0:	ef 91       	pop	r30
 8e2:	df 91       	pop	r29
 8e4:	cf 91       	pop	r28
 8e6:	bf 91       	pop	r27
 8e8:	af 91       	pop	r26
 8ea:	9f 91       	pop	r25
 8ec:	8f 91       	pop	r24
 8ee:	7f 91       	pop	r23
 8f0:	6f 91       	pop	r22
 8f2:	5f 91       	pop	r21
 8f4:	4f 91       	pop	r20
 8f6:	3f 91       	pop	r19
 8f8:	2f 91       	pop	r18
 8fa:	1f 91       	pop	r17
 8fc:	0f 91       	pop	r16
 8fe:	ff 90       	pop	r15
 900:	ef 90       	pop	r14
 902:	df 90       	pop	r13
 904:	cf 90       	pop	r12
 906:	0f 90       	pop	r0
 908:	0b be       	out	0x3b, r0	; 59
 90a:	0f 90       	pop	r0
 90c:	0f be       	out	0x3f, r0	; 63
 90e:	0f 90       	pop	r0
 910:	1f 90       	pop	r1
 912:	18 95       	reti

00000914 <chip_init>:

//***** chip Initialization **********************************
void chip_init(void){
	
	
	CLKPR = ( 1 << CLKPCE );  		// Set Clock Prescaler change enable
 914:	e1 e6       	ldi	r30, 0x61	; 97
 916:	f0 e0       	ldi	r31, 0x00	; 0
 918:	80 e8       	ldi	r24, 0x80	; 128
 91a:	80 83       	st	Z, r24
	CLKPR = 0x00;				// no prescaler CLK 16Mhz
 91c:	10 82       	st	Z, r1
	
	DDRE = 0x10;	// stat led output
 91e:	80 e1       	ldi	r24, 0x10	; 16
 920:	8d b9       	out	0x0d, r24	; 13
	PORTE |= (1<<PE4);
 922:	74 9a       	sbi	0x0e, 4	; 14
 924:	08 95       	ret

00000926 <main>:

void chip_init (void);

int main( void )
{
	USARTInit(51);	// UBRR = 51  19200 Baud
 926:	83 e3       	ldi	r24, 0x33	; 51
 928:	90 e0       	ldi	r25, 0x00	; 0
 92a:	43 d0       	rcall	.+134    	; 0x9b2 <USARTInit>
	chip_init();	// Chip initialization
 92c:	f3 df       	rcall	.-26     	; 0x914 <chip_init>
	can_init(250); 	// Can initialization
 92e:	8a ef       	ldi	r24, 0xFA	; 250
 930:	90 e0       	ldi	r25, 0x00	; 0
 932:	22 dc       	rcall	.-1980   	; 0x178 <can_init>
	int_ADC();
 934:	cd db       	rcall	.-2150   	; 0xd0 <int_ADC>
	sei();
 936:	78 94       	sei
	
	
	uint16_t toggle = 0;
	
	can_rx(FUNCTION);
 938:	84 e0       	ldi	r24, 0x04	; 4
 93a:	92 e0       	ldi	r25, 0x02	; 2
 93c:	69 dc       	rcall	.-1838   	; 0x210 <can_rx>
	can_init(250); 	// Can initialization
	int_ADC();
	sei();
	
	
	uint16_t toggle = 0;
 93e:	80 e0       	ldi	r24, 0x00	; 0
 940:	90 e0       	ldi	r25, 0x00	; 0
				}
				toggle = 1;
			}
			else{							// Else if not button "But" is pressed(High) then:
				if(toggle == 1){
					TransmitData[0] = 0x00;
 942:	c8 e0       	ldi	r28, 0x08	; 8
 944:	d1 e0       	ldi	r29, 0x01	; 1
					TransmitData[1] = 0x03;
 946:	0f 2e       	mov	r0, r31
 948:	f3 e0       	ldi	r31, 0x03	; 3
 94a:	df 2e       	mov	r13, r31
 94c:	f0 2d       	mov	r31, r0
					TransmitData[2] = 0x04;
 94e:	68 94       	set
 950:	99 24       	eor	r9, r9
 952:	92 f8       	bld	r9, 2
					can_tx(MASTERID, 3);
				}
				toggle = 0;
 954:	e1 2c       	mov	r14, r1
 956:	f1 2c       	mov	r15, r1
		while(1){
			
			if ((PINE & (1<<PE5)) == 0){	// If button "But" is pressed (Grounded) then:
				if(toggle == 0){
					
					TransmitData[0] = 0x3D;
 958:	0f 2e       	mov	r0, r31
 95a:	fd e3       	ldi	r31, 0x3D	; 61
 95c:	af 2e       	mov	r10, r31
 95e:	f0 2d       	mov	r31, r0
					TransmitData[1] = 0x01;
 960:	bb 24       	eor	r11, r11
 962:	b3 94       	inc	r11
					TransmitData[2] = 0x02;
 964:	68 94       	set
 966:	cc 24       	eor	r12, r12
 968:	c1 f8       	bld	r12, 1
					can_tx(MASTERID, 3);
					getADC(0);
				}
				toggle = 1;
 96a:	01 e0       	ldi	r16, 0x01	; 1
 96c:	10 e0       	ldi	r17, 0x00	; 0
 96e:	05 c0       	rjmp	.+10     	; 0x97a <main+0x54>
 970:	80 2f       	mov	r24, r16
 972:	91 2f       	mov	r25, r17
 974:	02 c0       	rjmp	.+4      	; 0x97a <main+0x54>
					TransmitData[0] = 0x00;
					TransmitData[1] = 0x03;
					TransmitData[2] = 0x04;
					can_tx(MASTERID, 3);
				}
				toggle = 0;
 976:	8e 2d       	mov	r24, r14
 978:	9f 2d       	mov	r25, r15
	}
	
	else{
		while(1){
			
			if ((PINE & (1<<PE5)) == 0){	// If button "But" is pressed (Grounded) then:
 97a:	65 99       	sbic	0x0c, 5	; 12
 97c:	0e c0       	rjmp	.+28     	; 0x99a <main+0x74>
				if(toggle == 0){
 97e:	89 2b       	or	r24, r25
 980:	b9 f7       	brne	.-18     	; 0x970 <main+0x4a>
					
					TransmitData[0] = 0x3D;
 982:	a8 82       	st	Y, r10
					TransmitData[1] = 0x01;
 984:	b9 82       	std	Y+1, r11	; 0x01
					TransmitData[2] = 0x02;
 986:	ca 82       	std	Y+2, r12	; 0x02
					can_tx(MASTERID, 3);
 988:	6d 2d       	mov	r22, r13
 98a:	87 e1       	ldi	r24, 0x17	; 23
 98c:	93 e0       	ldi	r25, 0x03	; 3
 98e:	63 dc       	rcall	.-1850   	; 0x256 <can_tx>
					getADC(0);
 990:	80 e0       	ldi	r24, 0x00	; 0
 992:	a7 db       	rcall	.-2226   	; 0xe2 <getADC>
				}
				toggle = 1;
 994:	80 2f       	mov	r24, r16
 996:	91 2f       	mov	r25, r17
 998:	f0 cf       	rjmp	.-32     	; 0x97a <main+0x54>
			}
			else{							// Else if not button "But" is pressed(High) then:
				if(toggle == 1){
 99a:	01 97       	sbiw	r24, 0x01	; 1
 99c:	61 f7       	brne	.-40     	; 0x976 <main+0x50>
					TransmitData[0] = 0x00;
 99e:	18 82       	st	Y, r1
					TransmitData[1] = 0x03;
 9a0:	d9 82       	std	Y+1, r13	; 0x01
					TransmitData[2] = 0x04;
 9a2:	9a 82       	std	Y+2, r9	; 0x02
					can_tx(MASTERID, 3);
 9a4:	6d 2d       	mov	r22, r13
 9a6:	87 e1       	ldi	r24, 0x17	; 23
 9a8:	93 e0       	ldi	r25, 0x03	; 3
 9aa:	55 dc       	rcall	.-1878   	; 0x256 <can_tx>
				}
				toggle = 0;
 9ac:	8e 2d       	mov	r24, r14
 9ae:	9f 2d       	mov	r25, r15
 9b0:	e4 cf       	rjmp	.-56     	; 0x97a <main+0x54>

000009b2 <USARTInit>:
#include <avr/io.h>

void USARTInit(uint16_t ubrr_value){

	//Set Baud rate
	UBRR0L = ubrr_value;
 9b2:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	UBRR0H = (ubrr_value>>8);
 9b6:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	/*	Set Frame Format:
	>> Asynchronous mode
	>> No Parity
	>> 1 StopBit
	>> char size 8		*/
	UCSR0C=(0<<UMSEL0)|(1<<UCSZ00)|(1<<UCSZ01);
 9ba:	86 e0       	ldi	r24, 0x06	; 6
 9bc:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>

	//Enable The receiver and transmitter
	UCSR0B=(1<<RXEN0)|(1<<TXEN0);
 9c0:	88 e1       	ldi	r24, 0x18	; 24
 9c2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 9c6:	08 95       	ret

000009c8 <USARTWriteChar>:

//This function writes the given "data" to
//the USART which then transmit it via TX line
void USARTWriteChar(char data)
{
	while(!(UCSR0A & (1<<UDRE0))){}	//Wait until previous writing to rs232 is ready
 9c8:	e0 ec       	ldi	r30, 0xC0	; 192
 9ca:	f0 e0       	ldi	r31, 0x00	; 0
 9cc:	90 81       	ld	r25, Z
 9ce:	95 ff       	sbrs	r25, 5
 9d0:	fd cf       	rjmp	.-6      	; 0x9cc <USARTWriteChar+0x4>

	UDR0=data;	// Write data to RS232
 9d2:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 9d6:	08 95       	ret

000009d8 <_exit>:
 9d8:	f8 94       	cli

000009da <__stop_program>:
 9da:	ff cf       	rjmp	.-2      	; 0x9da <__stop_program>
