/*************************************************************************
Title:    Main Control Unit for HU-2
Author:   Jeroen Mostert, LCD Library by peterfleury
File:     main.c
Software: AVR-GCC 4.x
Hardware: Main Control Unit V1.1
**************************************************************************/

#include <stdlib.h>
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include "lcd.h"

#define GAS1MIN 600
#define GAS1MAX 1020
#define GAS2MIN 600
#define GAS2MAX	1020
#define BRAKEMIND	0
#define BRAKEMAXD	200

#define BRAKEPERCENT 0.03
#define RTDBRAKEPERCENT 0.25

#define DELTAGASVALUE 100
#define DELTABRAKEVALUE 30

#define motorcontrollerenable	PA7

#define RTDS					PC2
#define prechargeenable			PC3
#define mainrelais				PC4
#define runenable				PC5
#define pumpenable				PC6
#define multiplexerenable		PC7

#define button1					PD0
#define button2					PD1
#define bluebutton				PE6
#define greenbutton				PE7

#define s1						PG0
#define s2						PG1
#define s3						PG2

#define F_CPU  16000000UL;

//PORTC = (1 << 0)|(1 << 3)|(1 << 6);

volatile int lcd_status = 0, refresh_rate = 0, adc_fast = 0, adc_slow = 0, errorcode = 0, warning = 0, calibrating = 0, failedcalibration = 0, gas1failurecounter = 0, gas2failurecounter = 0, brakefailurecounter = 0, bluebutton_pressed = 0, greenbutton_pressed = 0, runenableint = 0;	
volatile int gassensor1min = 0, gassensor1max = 0, gassensor2min = 0, gassensor2max = 0, brakemin = 0, brakemax = 0, gasdelta1 = 0, gasdelta2 = 0, brakedelta = 0, gaspedalcheck = 0, gasbrakecheck = 0;
volatile char Linebuffer0[21], Linebuffer1[21], Linebuffer2[21], Linebuffer3[21];
volatile uint16_t gas1 = 0, gas2 = 0, brake = 0, steer = 0, TEMPL = 0, TEMPR = 0, ADCP6 = 0, ADCP7 = 0;
volatile float percent25gas = 0, percent5gasbrakecheck = 0, percentbrake = 0, RTDbrake = 0;



ISR(INT0_vect)							// Button1 External Interrupt
{
	_delay_ms(10);						// Delay for key debounce
	if (PIND & (1 << button1)){
		if(calibrating < 10){
			if((calibrating == 7) && (failedcalibration == 1)){
				calibrating++;
			}
			else{
				if((failedcalibration == 1) && (calibrating == 8)){
				}
				else if((calibrating == 8) && (failedcalibration == 0)){
					calibrating++;
				}
				else{
					getcalibrationvalues();
					calibrating++;
				}
			}
		}
		if((calibrating >= 9) && (bluebutton_pressed == 1) && (greenbutton_pressed == 1)){
//			lcd_fast_refresh();	
			if (lcd_status == 2){		
 				lcd_status = 0;		// Reset lcd status
			}
			else lcd_status++;	
			lcd_fast_refresh();	
		}
	}
}

ISR(INT1_vect)							// Button2 External Interrupt
{
	//do stuff
}

ISR(INT6_vect)							// Bluebutton External Interrupt
{
	_delay_ms(10);						// Delay for key debounce
	if (PINE & (1 << bluebutton)){
		if((calibrating >= 9) && (bluebutton_pressed == 0)){
			PORTA = (1 << motorcontrollerenable);
//			_delay_ms(100);
			PORTC = (1 << prechargeenable);
//			_delay_ms(1000);
			PORTC = (1 << mainrelais);
			bluebutton_pressed = 1;
		}
	}
}

ISR(INT7_vect)							// Greenbutton External Interrupt
{
	_delay_ms(10);
	if (PINE & (1 << greenbutton)){
		if ((calibrating >= 9) && (bluebutton_pressed == 1) && (greenbutton_pressed == 0)){
//			if(brake >= RTDbrake){				
				PORTC = (1 << RTDS);
//				_delay_ms(2500);
				PORTC = (0 << RTDS);
				PORTC = (1 << runenable);
				runenableint = 1;
				greenbutton_pressed = 1;
//			}
		}
	}
}


ISR(ADC_vect)							// ADC Conversion done Interrupt
{
// Small Explanation in Dropdown box
/*
ADC0-3 will be read every 10ms				100 times/second
ADC4-7 will be read every once every 40ms	 25 times/second

Timing Loop:
 2ms:	Gas1
 4ms:	Gas2
 6ms:	Brake
 8ms:	Steer
10ms:	ADC 4,5,6 or 7

ADC 4,5,6 and 7 will be switched and read in the fifth ADC Cycle(10ms). 
*/
	if(adc_fast == 0){
		gas1 = ADC;									// Place 10-bit ADC Value in gas1
		ADMUX++;									// Set ADMUX to ADC1
	}
	if(adc_fast == 1){
		gas2 = ADC;										// Place 10-bit ADC Value in gas2
		if(calibrating >= 9){
			gas2 = gas2 - (gassensor1min - gassensor2min);	// Adjust the offset to the same level
		}
		ADMUX++;										// Set ADMUX to ADC2
	}
	if(adc_fast == 2){
		brake = ADC;								// Place 10-bit ADC Value in brake
		ADMUX++;									// Set ADMUX to ADC3
	}	
	if(adc_fast == 3){
		steer = ADC;								// Place 10-bit ADC Value in steer
		if(adc_slow == 0){
			ADMUX++;								// Set ADMUX to ADC4
		}
		if(adc_slow == 1){
			ADMUX += 2;								// Set ADMUX to ADC5
		}
		if(adc_slow == 2){
			ADMUX += 3;								// Set ADMUX to ADC6
		}
		if(adc_slow == 3){
			ADMUX += 4;								// Set ADMUX to ADC7
		}
	}	
	if(adc_fast == 4){
		
		if(calibrating >= 9){
			checkpedals();
			checkpercentgaspedals();
			checkbrakeandgas();
			check_error_code();
		}
		
		if(adc_slow == 0){
			TEMPL = ADC;							// Place 10-bit ADC Value in TEMPL
		}
		if(adc_slow == 1){
			TEMPR = ADC;							// Place 10-bit ADC Value in TEMPR
		}
		if(adc_slow == 2){
			ADCP6 = ADC;							// Place 10-bit ADC Value in ADCP6
		}
		if(adc_slow == 3){
			ADCP7 = ADC;							// Place 10-bit ADC Value in ADCP7
		}
		
		if ((adc_slow >= 0) && (adc_slow <= 2)){	// Check if adc_slow can be raised
			adc_slow++;								// Raise adc_slow by 1
		}
		else adc_slow = 0;							// Reset adc_slow
		
		ADMUX = 0b010000000;						// Set ADMUX to ADC0
	}
	
	if ((adc_fast >= 0) && (adc_fast <= 3)){		// Check if adc_fast can be raised
		adc_fast++;									// Raise adc_fast by 1
	}
	else adc_fast = 0;								// Reset adc_fast
	
	
}


ISR(TIMER2_OVF_vect)					// Timer 2 Overflow Interrupt(4Hz)
{
	TCNT2 = 192;					// Set initial counter value(0.25 Seconds)
	lcd_fast_refresh();
}

ISR(TIMER0_OVF_vect)					// Timer 0 Overflow Interrupt(500Hz)
{
	TCNT0 = 130;						// Set initial counter value(2ms)
	ADCSRA |= (1 << ADSC);				// Start ADC Conversion
}


void getpedalpercentvalues(void)		// Get the percentage once for all the equations
{
	percent25gas = (gasdelta1/0.25) + gassensor1min;
	percentbrake = (brakedelta/BRAKEPERCENT) + brakemin;
	RTDbrake = (brakedelta/RTDBRAKEPERCENT) + brakemin;
	percent5gasbrakecheck = (gasdelta1/0.05) + gassensor1min;
}


void getcalibrationvalues(void)			// Puts the right ADC Value in the right variable
{
	if(calibrating == 1){
		gassensor1min = gas1;
	}
	if(calibrating == 2){
		gassensor1max = gas1; 
	}
	if(calibrating == 3){
		gassensor2min = gas2;
	}
	if(calibrating == 4){
		gassensor2max = gas2;
	}
	if(calibrating == 5){
		brakemin = brake;
	}
	if(calibrating == 6){
		brakemax = brake;
		checkcalibrationvalues();		// Only check values if all calibration values are obtained
		percentgascalibration();
		getpedalpercentvalues();
	}
}

void checkcalibrationvalues(void)		// Checks if the gained calibration values are within range and not faulty
{
	
	if((gassensor1min > GAS1MAX) || (gassensor1min < GAS1MIN)){
		gassensor1min = 0;
	}
	if((gassensor1max > GAS1MAX) || (gassensor1max < GAS1MIN)){
		gassensor1max = 0;
	}
	if((gassensor2min > GAS2MAX) || (gassensor2min < GAS2MIN)){
		gassensor2min = 0;
	}
	if((gassensor2max > GAS2MAX) || (gassensor2max < GAS2MIN)){
		gassensor2max = 0;
	}
	if((brakemin > BRAKEMAXD) || (brakemin < BRAKEMIND)){
		brakemin = 0;
	}
	if((brakemax > BRAKEMAXD) || (brakemax < BRAKEMIND)){
		brakemax = 0;
	}
	if((gassensor1min == 0 || gassensor1max == 0 || gassensor2min == 0 || gassensor2max == 0 || brakemin == 0 || brakemax == 0) && (calibrating == 6)){
		failedcalibration = 1;
	}
	
	gasdelta1 =  gassensor1max - gassensor1min;
	if ((gasdelta1 < DELTAGASVALUE) || (gasdelta1 < 0)){
		failedcalibration = 1;
	}
	///	set the offset to the same level
//	gasoffset = gassensor2min - gassensor1min
	
	gassensor2max = gassensor2max - abs(gassensor2min - gassensor1min);
	gassensor2min = gassensor2min - abs(gassensor2min - gassensor1min);
	///	
		
	gasdelta2 =  gassensor2max - gassensor2min;
	if ((gasdelta2 < DELTAGASVALUE) || (gasdelta2 < 0)){
		failedcalibration = 1;
	}
	
	brakedelta =  brakemax - brakemin;
	if ((brakedelta < DELTABRAKEVALUE) || (brakedelta < 0)){
		failedcalibration = 1;
	}	
}

void percentgascalibration (void)		// Checks if the calibrated gas pedal values have more then 10% difference
{
	int gasdeltamin, gasdeltamax;
	float gaspercentmin, gaspercentmax;
	
	gasdeltamin = abs(gassensor1min - gassensor2min);
	gasdeltamax = abs(gassensor1max - gassensor2max);
	gaspercentmin = gasdeltamin / gassensor1min;
	gaspercentmax = gasdeltamax / gassensor1max;
	
	if((gaspercentmin > 0.1) || (gaspercentmax > 0.1)){
		failedcalibration = 1;
	}
}



void checkpercentgaspedals(void)		// Checks if the gas pedals different more then 10% from each other
{
	int gasdelta;
	float gaspercent;
	
	gasdelta = abs(gas1 - gas2);
	gaspercent = gasdelta / gas1;
	
	if(gaspercent > 0.1){
		gaspedalcheck++;
	}
	if (gaspercent < 0.1){
		gaspedalcheck = 0;
	}
	if (gaspedalcheck == 10){
		errorcode = 1;
	}
}

void checkbrakeandgas(void)				// Checks if the brake is pressed when the gas is more than 25% pressed
{
	if(runenableint == 1){
		if((percent25gas <= gas1) && (percentbrake <= brake)){
			gasbrakecheck++;
		}
		if((percent25gas > gas1) && (percentbrake > brake)){
			gasbrakecheck = 0;
		}
		if(gasbrakecheck == 10){
			errorcode = 2;
			//motor controller uit en error code aan, aanzetten uit losse error check functie
		}
	}
	if((runenableint == 0) && (errorcode == 2)); //als error code zoveel waar is
		if(gas1 < percent5gasbrakecheck){
			errorcodereset();
			//motor controller weer aan en error code uit, aanzetten uit losse error check functie
		}
}

void checkpedals(void)					// Checks if the cables are still connector or if the value is out of range
{
	if(GAS1MAX < gas1 || GAS1MIN > gas1){
		gas1failurecounter++;
	}
	if(GAS2MAX < gas2 || GAS2MIN > gas2){
		gas2failurecounter++;
	}
	if(BRAKEMAXD < brake || BRAKEMIND > brake){
		brakefailurecounter++;
	}
	else{
		gas1failurecounter = 0;
		gas2failurecounter = 0;
		brakefailurecounter = 0;
	}
	if(gas1failurecounter == 10 || gas2failurecounter == 10 || brakefailurecounter == 10){
		errorcode = 3;
		//dikke errors
	}
}


void check_error_code(void)
{
	if(errorcode > 0){
		PORTC = (0 << runenable);
		runenableint = 0;
	}
}

void errorcodereset(void){
	errorcode = 0;
	PORTC = (0 << runenable);
	runenableint = 0;
}


void lcd_fast_refresh(void)				// LCD Fast Refresh
{
	snprintf (Linebuffer3, sizeof Linebuffer3,"                    "); // even snel ertussen gemieterd omdat start calibration niet weg wou gaan
	
//	lcd_clrscr();
	
	checkstatus();
	
	lcd_gotoxy(0 ,0);					// Set display to Line 0, Character 0
	lcd_puts(Linebuffer0);
	
	lcd_gotoxy(40 ,0);					// Set display to Line 1, Character 0
	lcd_puts(Linebuffer1);
	
	lcd_gotoxy(20 ,0);					// Set display to Line 2, Character 0
	lcd_puts(Linebuffer2);

	lcd_gotoxy(20 ,1);					// Set display to Line 3, Character 0
	lcd_puts(Linebuffer3);
}

void checkstatus(void)					// Checks the status of the LCD which screen to display
{
	if(calibrating == 0){
		lcd_start_calibration_screen();
	}
	if(calibrating == 1){
		lcd_no_throttle_screen();
		lcd_gas_sensor1_screen();
	}
	if(calibrating == 2){
		lcd_max_throttle_screen();
		lcd_gas_sensor1_screen();
	}
	if(calibrating == 3){
		lcd_no_throttle_screen();
		lcd_gas_sensor2_screen();
	}
	if(calibrating == 4){
		lcd_max_throttle_screen();
		lcd_gas_sensor2_screen();
	}
	if(calibrating == 5){
		lcd_no_brake_screen();
		lcd_brakesensor_screen();
	}
	if(calibrating == 6){
		lcd_max_brake_screen();
		lcd_brakesensor_screen();
	}
	if((calibrating == 7) && (failedcalibration == 0)){
		lcd_succeeded_calibration_screen();
	}
	if((calibrating == 7) && (failedcalibration == 1)){
		lcd_failed_calibration_screen();
	}
	if(calibrating == 8){
		lcd_calibration_values_screen();
	}
	if(calibrating >= 9){
		
		if((calibrating >= 9) && (bluebutton_pressed == 0)){
			lcd_blue_screen();
		}
		if ((calibrating >= 9) && (bluebutton_pressed == 1) && (greenbutton_pressed == 0)){
			lcd_green_screen();
		}
		if((calibrating >= 9) && (bluebutton_pressed == 1) && (greenbutton_pressed == 1)){

			lcd_cont_screen();
			
			if (lcd_status == 0){
				lcd_motor_screen();
			}
			if (lcd_status == 1){
				lcd_water_screen();
			}
			if (lcd_status == 2){
				lcd_batteries_screen();
			}
		}
	}
}


void lcd_succeeded_calibration_screen(void)
{
	//	snprintf (Linebuffer0, sizeof Linebuffer0,"  ");
	snprintf (Linebuffer1, sizeof Linebuffer1,"    Calibration  ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"     Succeeded   ");
	snprintf (Linebuffer0, sizeof Linebuffer0,"                    "); // even snel ertussen gemieterd omdat min max niet weg wou gaan
}

void lcd_welcome_screen(void){
	snprintf (Linebuffer0, sizeof Linebuffer0,"        Hello       ");
	snprintf (Linebuffer1, sizeof Linebuffer1,"    I am the HU-2   ");
}

void lcd_start_calibration_screen(void){
	snprintf (Linebuffer3, sizeof Linebuffer3," Start Calibration  ");
}

void lcd_failed_calibration_screen(void)
{
	//	snprintf (Linebuffer0, sizeof Linebuffer0,"  ");
	snprintf (Linebuffer1, sizeof Linebuffer1,"    Calibration  ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"      Failed ");
	snprintf (Linebuffer0, sizeof Linebuffer0,"                    "); // even snel ertussen gemieterd omdat min max niet weg wou gaan
}

void lcd_gas_sensor1_screen(void){
	snprintf (Linebuffer1, sizeof Linebuffer1,"Sensor 1 Value:%d   ",gas1);
}

void lcd_gas_sensor2_screen(void){
	snprintf (Linebuffer1, sizeof Linebuffer1,"Sensor 2 Value:%d   ",gas2);
}

void lcd_max_throttle_screen(void){
	snprintf (Linebuffer0, sizeof Linebuffer0,"   Max Throttle ");
}

void lcd_no_throttle_screen(void){
	snprintf (Linebuffer0, sizeof Linebuffer0,"   No Throttle   ");
}

void lcd_brakesensor_screen(void){
	snprintf (Linebuffer1, sizeof Linebuffer1,"Sensor Value:%d   ",brake);
}

void lcd_no_brake_screen(void){
	snprintf (Linebuffer0, sizeof Linebuffer0,"     No Brake");
}

void lcd_max_brake_screen(void){
	snprintf (Linebuffer0, sizeof Linebuffer0,"     Max Brake");
}

void lcd_calibration_values_screen(void)	// Displays all calibration values
{
	snprintf (Linebuffer0, sizeof Linebuffer0,"      Min Delta  Max");
	snprintf (Linebuffer1, sizeof Linebuffer1,"Gas1: %.3d %.3d  %.4d", gassensor1min, gasdelta1 ,gassensor1max);
	snprintf (Linebuffer2, sizeof Linebuffer2,"Gas2: %.3d %.3d  %.4d", gassensor2min, gasdelta2, gassensor2max);
	snprintf (Linebuffer3, sizeof Linebuffer3,"Brake:%.3d %.3d  %.4d", brakemin, brakedelta, brakemax);
}



void lcd_motor_screen(void)				// LCD Motor Control Screen
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"     C MOTOR       C");
	snprintf (Linebuffer2, sizeof Linebuffer2,"     C CONTR       C");
}

void lcd_water_screen(void)				// LCD Watercooling Screen
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"%d   C  WATER %d   C", TEMPL, TEMPR);
	snprintf (Linebuffer2, sizeof Linebuffer2,"    L/m FLOW     L/m");
}

void lcd_batteries_screen(void)			// LCD Batteries Screen
{
		snprintf (Linebuffer1, sizeof Linebuffer1,"     Battery        ");
		snprintf (Linebuffer2, sizeof Linebuffer2,"     Screen         ");
}

void lcd_blue_screen(void)				// LCD Press Blue Button Screen
{
	snprintf (Linebuffer1, sizeof Linebuffer0," Press Blue Button  ");
}

void lcd_green_screen(void)				// LCD Press Green Button Screen
{
	snprintf (Linebuffer1, sizeof Linebuffer0," Press Green Button ");
}

void lcd_cont_screen(void)				// LCD Race Screen/Home Screen
{
	snprintf (Linebuffer0, sizeof Linebuffer0,"  Speed:      KM/H  ");
	
	snprintf (Linebuffer3, sizeof Linebuffer3,"H:   V/    A L:    V");
}



void initMCU(void)						// Initialize whole MCU
{
	init_ADC();
	init_TIMER0();
	init_TIMER2();
	lcd_init(LCD_DISP_ON);		// Initialize display, cursor off
	init_IO();
	init_external_interrupts();

	sei();						// Enable Global Interrupts

	lcd_welcome_screen();		
	lcd_fast_refresh();
}

void init_TIMER0(void)					// 500Hz Clock Initialization (Timer Counter 0)
{
	TCCR0A |= (1 << CS02);					// 256 Prescaler
	TCNT0 = 130;							// Set initial counter value(2ms)
	TIMSK0 |= (1 << TOIE0);					// Overflow Interrupt Enable
}

void init_TIMER2(void)					//   4Hz Clock Initialization (Timer Counter 2)
{
		ASSR  = (1<< AS2);						// Enable asynchronous mode
		TCNT2 = 192;							// Set initial counter value(0.25 Seconds)
		TCCR2A |= (1 << CS02)|(1 << CS00);		// 128 Prescaler ((255*128)/32.786 = 1Hz)
		TIFR2   = (1 << TOV2);					// Clear interrupt flags
		TIMSK2  = (1 << TOIE2);					// Enable TOV2 interrupt
}

void init_ADC(void)						// ADC Initialization
{
		DDRF = 0x00;											// PortF All Inputs
		PORTF = 0x00;											// PortF Pullup Disabled	
	
		ADCSRA |= (1 << ADEN);									// Enable ADC
		ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);	// 128 PreScaler
//		ADMUX |= ( 0 << REFS1) | (0 << REFS0);					// Set 5V Ref Voltage on AVcc
		ADMUX &= ~((1<<REFS0)|(1<<REFS1));
		ADCSRA |= (1 << ADIE);									// Enable ADC Interrupt
}

void init_IO(void)						// Initialize Input and Output Ports en Pins
{
	DDRE &=~ ((1 << bluebutton) | (1 << greenbutton));		// Inputs
	PORTE |= ((1 << bluebutton) | (1 << greenbutton));		// Pull-up enabled
	
	DDRD &=~ ((1 << button1) | (1 << button2));				// Inputs
	PORTD |= ((1 << button1) | (1 << button2));				// Pull-up enabled
	
	DDRC &=~ 0;												// PORTC are all outputs
	PORTC |= ((1 << mainrelais) | (1 << RTDS) | (1 << prechargeenable) | (1 << pumpenable) | (1 << runenable) | (1 << multiplexerenable));        // Pull-up enabled
}

void init_external_interrupts(void)		// Initialize External Interrupts
{
	EIMSK |= (1 << INT6 | (1 << INT7) | (1 << INT0) | (1 << INT1));					// Enable External Interrupts
	EICRB  |= (0 << ISC51) | (0 << ISC50);											// Falling edge creates interrupt
}



int main()								// Main function
{
		initMCU();

//	    DDRE &=~ (1 << PE5);        // Pin PE5 input              
//	    PORTE |= (1 << PE5);        // Pin PE5 pull-up enabled  

//		EIMSK |= (1 << INT5);					// Enable Interrupt 5
//		EICRB  |= (0 << ISC51) | (0 << ISC50);	// Falling edge creates interrupt
			
		while(1){
			
		}
		
}
