/*************************************************************************
Title:    Main Control Unit for HU-2
Author:   Jeroen Mostert, LCD Library by peterfleury
File:     main.c
Software: AVR-GCC 4.x
Hardware: Main Control Unit V1.1
**************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdbool.h>
#include "lcd.h"


#define BRAKINGVALUE			65

#define DELTAGASVALUE			50
#define DELTABRAKEVALUE			50


#define MAXDISTANCE				50		// maximum distance from the maximum, 0 and 1025 (0 + MAXDISTANCE) & (1023 - MAXDISTANCE)
#define MAXPEDALSHOOT			5		// In percentage, maximum pedal over and undershoot 

#define MAXOVERLAP				5		// In Percentage of overlap between the 2 gaspedal sensors(to determine the minimum offset)



#define motorcontrollerenable	PA7

#define RTDS					PC2
#define prechargeenable			PC3
#define mainrelais				PC4
#define runenable				PC5
#define pumpenable				PC6
#define multiplexerenable		PC7

#define button1					PD0
#define button2					PD1
#define bluebutton				PE6
#define greenbutton				PE7

#define Brakelight				PC1
#define MCoverheating			PE0

#define s1						PG0
#define s2						PG1
#define s3						PG2

//functies droppen


volatile int gas1 = 0, gas2 = 0, brake = 0, steer = 0, TEMPL = 0, TEMPR = 0, ADCP6 = 0, ADCP7 = 0;
volatile int gassensor1min = 0, gassensor1max = 0, gassensor2min = 0, gassensor2max = 0, brakemin = 0, brakemax = 0, gasdelta1 = 0, gasdelta2 = 0, brakedelta = 0, gaspercentcounter = 0, gasbrakecheck = 0, gasoffset = 0;
volatile int lcd_status = 0, refresh_rate = 0, adc_fast = 0, adc_slow = 0, errorcode = 0, warningcode = 0, calibrating = 0,  gas1failurecounter = 0, gas2failurecounter = 0, brakefailurecounter = 0;	
volatile bool bluebutton_pressed = 0, greenbutton_pressed = 0, failedcalibration = 0, succeededcalibration = 0, runenablebool = 0;
volatile int percent25gas = 0, percent5gasbrakecheck = 0, braking = 0, watertempR = 0, watertempL = 0, calerrorcode = 0;
volatile char Linebuffer0[21], Linebuffer1[21], Linebuffer2[21], Linebuffer3[21];

void lcd_welcome_screen(void)			// Hardware & Software version welcome screen
{
	snprintf (Linebuffer0, sizeof Linebuffer0,"  HU-2     Version  ");
	snprintf (Linebuffer1, sizeof Linebuffer1,"Hardware:  V1.1     ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"Software:  beta     ");
}

ISR(INT0_vect)							// Button1 External Interrupt
{
	_delay_ms(8);						// Delay for key debounce
	if ((PIND & (1 << button1)) && (errorcode == 0)){
		if(calibrating == 4 && failedcalibration == 0){
			succeededcalibration = 1;
			calibrating++;
		}
		if(calibrating == 4 && failedcalibration == 1){
			calibrating++;
		}
		if(calibrating == 3){
			calibrating++;
		}
		if(calibrating <= 2){
			getcalibrationvalues();
			calibrating++;
		}
		if((succeededcalibration == 1) && (bluebutton_pressed == 1) && (greenbutton_pressed == 1)){
			if (lcd_status == 2){		
 				lcd_status = 0;		// Reset lcd status
			}
			else lcd_status++;	
			lcd_fast_refresh();	
		}
	}
}

/*
ISR(INT1_vect)							// Button2 External Interrupt
{
	//do stuff
}
*/

ISR(INT6_vect)							// Bluebutton External Interrupt
{
	_delay_ms(8);						// Delay for key debounce
	if (!(PINE & (1 << bluebutton))){
		if((succeededcalibration == 1) && (bluebutton_pressed == 0)){
			PORTA |= (1 << motorcontrollerenable);
			_delay_ms(100);
			PORTC |= (1 << prechargeenable);
			_delay_ms(1000);
			PORTC |= (1 << mainrelais);
			bluebutton_pressed = 1;
			lcd_fast_refresh();
		}
	}
}

ISR(INT7_vect)							// Greenbutton External Interrupt
{
	_delay_ms(8);
	if (!(PINE & (1 << greenbutton))){
		if ((succeededcalibration == 1) && (bluebutton_pressed == 1) && (greenbutton_pressed == 0)){
			if(brake >= braking){				
				PORTC |= (1 << RTDS);
				_delay_ms(2000);
				PORTC &= ~(1 << RTDS);
				PORTC |= (1 << runenable);
				runenablebool = 1;
				greenbutton_pressed = 1;
				lcd_fast_refresh();
			}
		}
	}
}


ISR(ADC_vect)							// ADC Conversion done Interrupt
{
// Small Explanation in Dropdown box
/*
ADC0-3 will be read every 10ms				100 times/second
ADC4-7 will be read every once every 40ms	 25 times/second

Timing Loop:
 2ms:	Gas1
 4ms:	Gas2
 6ms:	Brake
 8ms:	Steer
10ms:	ADC 4,5,6 or 7

ADC 4,5,6 and 7 will be switched and read in the fifth ADC Cycle(10ms). 
*/
	if(adc_fast == 0){
		gas1 = ADC;									// Place 10-bit ADC Value in gas1
		ADMUX++;									// Set ADMUX to ADC1
		checkpedalcables(gas1, 6);
	}
	if(adc_fast == 1){
		gas2 = ADC;									// Place 10-bit ADC Value in gas2
		checkpedalcables(gas2, 7);
//		checkpercentgaspedals();					// deze moet weer aan als de gassensoren mechanisch gefixt zijn
		ADMUX++;									// Set ADMUX to ADC2
	}
	if(adc_fast == 2){
		brake = ADC;								// Place 10-bit ADC Value in brake
		checkpedalcables(brake, 8);
		checkbrakeandgas();
		checkbrakelight();							// Checks if the brake light has to be activated
		ADMUX++;									// Set ADMUX to ADC3
	}	
	if(adc_fast == 3){
		steer = ADC;								// Place 10-bit ADC Value in steer
		if(adc_slow == 0){
			ADMUX++;								// Set ADMUX to ADC4
		}
		if(adc_slow == 1){
			ADMUX += 2;								// Set ADMUX to ADC5
		}
		if(adc_slow == 2){
			ADMUX += 3;								// Set ADMUX to ADC6
		}
		if(adc_slow == 3){
			ADMUX += 4;								// Set ADMUX to ADC7
		}
	}	
	if(adc_fast == 4){								// These ADC's will be read once every 40ms
		if(adc_slow == 0){
			TEMPL = ADC;							// Place 10-bit ADC Value in TEMPL
		}
		if(adc_slow == 1){
			TEMPR = ADC;							// Place 10-bit ADC Value in TEMPR
		}
		if(adc_slow == 2){
			ADCP6 = ADC;							// Place 10-bit ADC Value in ADCP6
		}
		if(adc_slow == 3){
			ADCP7 = ADC;							// Place 10-bit ADC Value in ADCP7
		}
		
		if ((adc_slow >= 0) && (adc_slow <= 2)){	// Check if adc_slow can be raised
			adc_slow++;								// Raise adc_slow by 1
		}
		else adc_slow = 0;							// Reset adc_slow
		
		ADMUX = 0b010000000;						// Set ADMUX to ADC0
	}
	
	if ((adc_fast >= 0) && (adc_fast <= 3)){		// Check if adc_fast can be raised
		adc_fast++;									// Raise adc_fast by 1
	}
	else adc_fast = 0;								// Reset adc_fast
}


ISR(TIMER2_OVF_vect)					// Timer 2 Overflow Interrupt(4Hz)
{
	TCNT2 = 192;						// Set initial counter value(0.25 Seconds)
	lcd_fast_refresh();					// Refresh LCD Screen
	checkoverheating();					// Checks if the cooling pumps have to be enabled (no interrupt needed, timing is not crucial)
}

ISR(TIMER0_OVF_vect)					// Timer 0 Overflow Interrupt(500Hz)
{
	TCNT0 = 130;						// Set initial counter value(2ms)
	ADCSRA |= (1 << ADSC);				// Start ADC Conversion
}


void getpedalpercentvalues(void)		// Get the percentage once for all the equations
{
	percent25gas = (gasdelta1*0.25) + gassensor1min;			// Get the value of 25% pedal travel of the gaspedal
	braking = BRAKINGVALUE + brakemin;							// Get the value of the minimum brake pedal travel
	percent5gasbrakecheck = (gasdelta1*0.05) + gassensor1min;	// Get the value of  5% pedal travel of the gaspedal
}


void getcalibrationvalues(void)			// Puts the right ADC Value in the right variable
{
	if(calibrating == 1){
		gassensor1min = gas1;
		gassensor2min = gas2;
		brakemin = brake;
	}
	if(calibrating == 2){
		gassensor1max = gas1;
		gassensor2max = gas2;
		brakemax = brake;
		checkdeltas();					// Only check values if all calibration values are obtained
		getpedalpercentvalues();		// Get the percentage once for all the equations
		checkoffset();					// Check if the offset is high enough
		checkpedalrange();				// Check if the range does not come close to 0 and 1023
		
		if(calerrorcode > 0){
			failedcalibration = 1;
		}
	}
}

void checkdeltas(void)					// Checks if the gained deltas are high enough
{
	gasdelta1 =  gassensor1max - gassensor1min;			// Get the delta of gassensor1
	if (gasdelta1 < DELTAGASVALUE){						// Checks if the delta is more then defined
//		failedcalibration = 1;
		calerrorcode = 1;
	}

	gasdelta2 =  gassensor2max - gassensor2min;			// Get the delta of gassensor1
	if (gasdelta2 < DELTAGASVALUE){						// Checks if the delta is more then defined
//		failedcalibration = 1;
		calerrorcode = 2;
	}
	
	brakedelta =  brakemax - brakemin;					// Get the delta of the brake
	if (brakedelta < DELTABRAKEVALUE){					// Checks if the delta is more then defined
//		failedcalibration = 1;
		calerrorcode = 3;
	}	
}

void checkoffset(void)					// Checks if the offset is high enough
{	
	int overlap = 0, offset = 0;
	
	if(gasdelta1 >= gasdelta2){
		offset = (gasdelta2 * (1 - (MAXOVERLAP/100)));
	}
	if(gasdelta2 > gasdelta1){
		offset = (gasdelta1 * (1 - (MAXOVERLAP/100)));
	}
	
	if(gassensor1min >= gassensor2min){
		overlap = gassensor2max - gassensor1min;
	}
	if(gassensor2min > gassensor1min){
		overlap = gassensor1max - gassensor2min;
	}
	
	if(overlap > offset){
		calerrorcode = 4;
	}
}

void checkpedalrange(void)				// Checks if the maximum and minimum values are not near 0 and 1023
{
	int min = 0, max = 0, mingassensor1min = 0, maxgassensor1max = 0 , mingassensor2min = 0 , maxgassensor2max = 0, minbrakemin = 0, maxbrakemax = 0, pedalshoot = 0;
	
	min = 0 + MAXDISTANCE;
	max = 1023 - MAXDISTANCE;
	pedalshoot = MAXPEDALSHOOT/100;
	
	mingassensor1min = gassensor1min - (gasdelta1 * pedalshoot);
	maxgassensor1max = gassensor1max + (gasdelta1 * pedalshoot);
	mingassensor2min = gassensor2min - (gasdelta2 * pedalshoot);
	maxgassensor2max = gassensor2max + (gasdelta2 * pedalshoot);
	minbrakemin = brakemin - (brakedelta * pedalshoot);
	maxbrakemax = brakemax + (brakedelta * pedalshoot);
	
	if((maxgassensor1max > max) || (mingassensor1min < min)){
		calerrorcode = 5;
	}
	if((maxgassensor2max > max) || (mingassensor2min < min)){
		calerrorcode = 6;
	}
	if((maxbrakemax > max) || (minbrakemin < min)){
		calerrorcode = 7;
	}
}



void checkpedalcables(int sensorcable, int error)				// Check if the cables are still attached(EV 2.4.5, EV 2.3.10)
{	
	//  Atmega internal pull-up will pull up to 5V when a cable is disconnected or faulty, so the ADC value becomes 1023
	if ((errorcode == 0) && (calibrating > 0)){
		if(sensorcable == 1023){					// When Gas Senor 1 is disconnected or the cable is faulty
			errorcode = error;
		}
		checkerrorcode();
	}
	
}

void checkpercentgaspedals(void)		// Checks if the gas pedals different more then 10% from each other(EV 2.3.5)
{
	if(runenablebool == 1){
		int gasmindelta1 = 0, gas1percent = 0, gasmindelta2 = 0, gas2percent = 0, gaspercentdifference = 0;
		
		gasmindelta1 = gas1 - gassensor1min;
		gas1percent = (gasmindelta1 *100) / gasdelta1;
		
		gasmindelta2 = gas2 - gassensor2min;
		gas2percent = (gasmindelta2 *100) / gasdelta2;
		
		if(gas2percent >= gas1percent){
			gaspercentdifference = gas2percent - gas1percent;
		}
		if(gas2percent < gas1percent){
			gaspercentdifference = gas1percent - gas2percent;
		}
		
		if(gaspercentdifference > 10){					// If they differ more than 10%
			gaspercentcounter++;						// Start a counter by adding 1
		}
		if(gaspercentdifference <= 10){					// If they differ less than 10% 
			gaspercentcounter = 0;						// The counter will be reset
		}
		if(gaspercentcounter == 10){					// If the counter reaches 10(10 * 10ms = 100ms)
			errorcode = 1;								// An Error will occur
			checkerrorcode();
		}
	}
}

void checkbrakeandgas(void)				// Checks if the brake is pressed when the gas is more than 25% pressed(EV 2.5)
{
	if(runenablebool == 1){										// Only do this when run enable is on
		if((percent25gas <= gas1) && (braking <= brake) && (errorcode == 0)){	// If the gas pedal travel is more then 25% and the brake pedal travel is more than minimum
			errorcode = 2;										// An Error will occur
			checkerrorcode();
		}
	}
	// If this error occurs the car may start again if the gas pedal travel is less then 5%, brake pedal travel is not important here(EV 2.5.1)
	if((runenablebool == 0) && (errorcode == 2)){				// If run enable is turned off by this error and the error code is on
		if(gas1 < percent5gasbrakecheck){						// Check if the gas pedal travel is less than 5%
			errorcodereset();									// Reset the error code and turn run enable on again			
		}
	}
}



void checkbrakelight(void)				// Checks if the brakes are being pressed and turns the brakelight on/off 
{
	if(succeededcalibration == 1){
		if(brake >= braking){				// If brake is higher than the minimum brake value
			PORTC |= (1 << Brakelight);		// Turn the brake lights on
		}
		if(brake < (braking - 15)){			// If brake is lower than the minimum brake value minus a bit more(preventing brakelight flickering)
			PORTC &= ~(1 << Brakelight);	// Turn the brake lights off
		}
	}
}

void checkoverheating(void)				// Checks if the cooling pumps have to be enabled
{
	if (PINE & (1 << MCoverheating)){	// Check if the overheating pin is logic high
		PORTC |= (1 << pumpenable);		// Enable cooling pumps
	}
	else{
		PORTC &= ~(1 << pumpenable);		// Disable cooling pumps
	}
}


void checkerrorcode(void)				// Checks if an Error occurred
{
	if(errorcode > 0){					// If there any Error occurred
		PORTC &= ~(1 << runenable);		// Turn off the run enable pin
		runenablebool = 0;				// set the run enable to zero
		lcd_fast_refresh();
	}
}

void errorcodereset(void)				// Resets the error code and turn run enable on
{
	errorcode = 0;						// Reset Errorcode
	PORTC |= (1 << runenable);			// Turn run enable on again
	runenablebool = 1;					// Set run enable to one again
	lcd_fast_refresh();
}



void lcd_fast_refresh(void)				// LCD Fast Refresh
{
	checklcdstatus();						// Checks the status so it knows which screen has to be put on the LCD screen
/*	
	if(calibrating == 5 & calerrorcode > 0){
		lcd_clrscr();
	}
*/	
	lcd_gotoxy(0 ,0);					// Set display to Line 0, Character 0
	lcd_puts(Linebuffer0);
	
	lcd_gotoxy(40 ,0);					// Set display to Line 1, Character 0
	lcd_puts(Linebuffer1);
	
	lcd_gotoxy(20 ,0);					// Set display to Line 2, Character 0
	lcd_puts(Linebuffer2);

	lcd_gotoxy(20 ,1);					// Set display to Line 3, Character 0
	lcd_puts(Linebuffer3);
}

void checklcdstatus(void)				// Checks the status of the LCD which screen to display
{
	if(errorcode == 0){
		if(calibrating == 0){
		}
		if(calibrating == 1){
			lcd_release_pedals_screen();
		}
		if(calibrating == 2){
			lcd_press_pedals_screen();
		}
		if((calibrating == 3) && (failedcalibration == 0)){
			lcd_succeeded_calibration_screen();
		}
		if((calibrating == 3) && (failedcalibration == 1)){
			lcd_failed_calibration_screen();
		}
		if(calibrating == 4){
			lcd_calibration_values_screen();
		}
		if((calibrating == 5) && (failedcalibration == 1)){
			if(calerrorcode == 1){
				lcd_calerrorcode_1_screen();
			}
			if(calerrorcode == 3){
				lcd_calerrorcode_2_screen();
			}
			if(calerrorcode == 3){
				lcd_calerrorcode_3_screen();
			}
			if(calerrorcode == 4){
				lcd_calerrorcode_4_screen();
			}
			if(calerrorcode == 5){
				lcd_calerrorcode_5_screen();
			}
			if(calerrorcode == 6){
				lcd_calerrorcode_6_screen();
			}
			if(calerrorcode == 7){
				lcd_calerrorcode_7_screen();
			}
		}
		if(succeededcalibration == 1){
			lcd_cont_screen();
			if(bluebutton_pressed == 0){
				lcd_blue_screen();
			}
			if ((bluebutton_pressed == 1) && (greenbutton_pressed == 0)){
				lcd_green_screen();
			}
			if((bluebutton_pressed == 1) && (greenbutton_pressed == 1)){
				if (lcd_status == 0){
					lcd_motor_screen();
				}
				if (lcd_status == 1){
	//				getwatertemperature();
					lcd_water_screen();
				}
				if (lcd_status == 2){
					lcd_batteries_screen();
				}
			}
		}
	}
	if(errorcode > 0){
		if(errorcode == 1){
			lcd_errorcode_1_screen();
		}
		if(errorcode == 2){
			lcd_errorcode_2_screen();
		}
		if(errorcode == 3){
			lcd_errorcode_3_screen();
		}
		if(errorcode == 4){
			lcd_errorcode_4_screen();
		}
		if(errorcode == 5){
			lcd_errorcode_5_screen();
		}
		if(errorcode == 6){
			lcd_errorcode_6_screen();
		}
		if(errorcode == 7){
			lcd_errorcode_7_screen();
		}
		if(errorcode == 8){
			lcd_errorcode_8_screen();
		}
//		if(calibrating >= 9){
//			lcd_cont_screen();
//		}
	}
	
}


void lcd_succeeded_calibration_screen(void)
{
	snprintf (Linebuffer0, sizeof Linebuffer0,"                    ");
	snprintf (Linebuffer1, sizeof Linebuffer1,"    Calibration     ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"     Succeeded      ");
}

void lcd_failed_calibration_screen(void)
{
	snprintf (Linebuffer0, sizeof Linebuffer0,"                    ");
	snprintf (Linebuffer1, sizeof Linebuffer1,"     Calibration    ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"       Failed       ");
	snprintf (Linebuffer3, sizeof Linebuffer3,"                    ");
}

void lcd_release_pedals_screen(void)
{
	snprintf (Linebuffer0, sizeof Linebuffer0,"                    ");
	snprintf (Linebuffer1, sizeof Linebuffer1,"       Release      ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"     Both Pedals    ");
	snprintf (Linebuffer3, sizeof Linebuffer3,"                    ");
}

void lcd_press_pedals_screen(void)
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"        Press       ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"    Both Pedals     ");
}

void lcd_calibration_values_screen(void)	// Displays all calibration values
{
	snprintf (Linebuffer0, sizeof Linebuffer0,"      Min Delta  Max");
	snprintf (Linebuffer1, sizeof Linebuffer1,"Gas1: %.3d %.3d  %.4d", gassensor1min, gasdelta1 ,gassensor1max);
	snprintf (Linebuffer2, sizeof Linebuffer2,"Gas2: %.3d %.3d  %.4d", gassensor2min, gasdelta2, gassensor2max);
	snprintf (Linebuffer3, sizeof Linebuffer3,"Brake:%.3d %.3d  %.4d", brakemin, brakedelta, brakemax);
}



void lcd_calerrorcode_1_screen(void)	// gasdelta1 te klein
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"	                  ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"  gas1 delta small  ");
}

void lcd_calerrorcode_2_screen(void)	// gasdelta2 te klein
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"	                   ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"  gas2 delta small  ");
}

void lcd_calerrorcode_3_screen(void)	// brake delta te klein
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"	                    ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"  brake delta small  ");
}

void lcd_calerrorcode_4_screen(void)	// offset is te klein
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"	                   ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"  offset to small   ");
	snprintf (Linebuffer3, sizeof Linebuffer3,"	                   ");
	snprintf (Linebuffer0, sizeof Linebuffer0,"	                   ");
}

void lcd_calerrorcode_5_screen(void)	// gas1 dicht bij max
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"	  sensor 1 near    ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"  minimum maximum   ");
}

void lcd_calerrorcode_6_screen(void)	// gas2 dicht bij max
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"	   sensor 2 near   ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"  minimum maximum   ");
}

void lcd_calerrorcode_7_screen(void)	// rem dicht bij
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"	     brake   near  ");
	snprintf (Linebuffer2, sizeof Linebuffer2," minimum maximum    ");
}



void lcd_errorcode_1_screen(void)		// 10% Gas Pedal difference
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"	     10% Gas       ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"  Pedal Difference  ");
}

void lcd_errorcode_2_screen(void)		// Gas & Brake pedals pressed at the same time
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"	    Gas & Brake    ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"   RELEASE PEDALS   ");
}

void lcd_errorcode_3_screen(void)		// Gas Sensor 1 Out of Defined Range
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"    Gas Sensor 1    ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"Out of Defined Range");
}

void lcd_errorcode_4_screen(void)		// Gas Sensor 2 Out of Defined Range
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"     Gas Senor 2    ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"Out of Defined Range");
}

void lcd_errorcode_5_screen(void)		// Brake Sensor out of Defined Range
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"    Brake Sensor    ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"Out of Defined Range");
}

void lcd_errorcode_6_screen(void)		// Gas Sensor 1 Cable Fault
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"    Gas Sensor 1     ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"    Cable Fault      ");
}

void lcd_errorcode_7_screen(void)		// Gas Sensor 2 Cable Fault
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"    Gas Sensor 2     ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"    Cable Fault      ");
}

void lcd_errorcode_8_screen(void)		// Brake Sensor Cable Fault
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"    Brake Sensor     ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"    Cable Fault      ");
}


void lcd_motor_screen(void)				// LCD Motor Control Screen
{
	snprintf (Linebuffer1, sizeof Linebuffer1,"     C MOTOR       C");
	snprintf (Linebuffer2, sizeof Linebuffer2,"     C CONTR       C");
}

void lcd_water_screen(void)				// LCD Watercooling Screen
{
//	snprintf (Linebuffer1, sizeof Linebuffer1,"%d   C  WATER %d   C", watertempL, watertempR);
	snprintf (Linebuffer1, sizeof Linebuffer1,"%d   C  WATER %d   C", TEMPL, TEMPR);
	snprintf (Linebuffer2, sizeof Linebuffer2,"    L/m FLOW     L/m");
}

void lcd_batteries_screen(void)			// LCD Batteries Screen
{
		snprintf (Linebuffer1, sizeof Linebuffer1,"     Battery        ");
		snprintf (Linebuffer2, sizeof Linebuffer2,"     Screen         ");
}


void lcd_blue_screen(void)				// LCD Press Blue Button Screen
{
	snprintf (Linebuffer1, sizeof Linebuffer1," Press Blue Button  ");
	snprintf (Linebuffer2, sizeof Linebuffer2,"                    ");
}

void lcd_green_screen(void)				// LCD Press Green Button Screen
{
	snprintf (Linebuffer1, sizeof Linebuffer0," Press Green Button ");
}


void lcd_cont_screen(void)				// LCD Race Screen/Home Screen
{
//	snprintf (Linebuffer0, sizeof Linebuffer0,"  Speed:      KM/H  ");
	snprintf (Linebuffer0, sizeof Linebuffer0,"RUNEN %d error %d", runenablebool, errorcode);
//	snprintf (Linebuffer3, sizeof Linebuffer3,"H:   V/    A L:    V");
	snprintf (Linebuffer3, sizeof Linebuffer3,"gas: %d  gas2 %d", gas1, gas2);
}




void initMCU(void)						// Initialize whole MCU
{
	init_ADC();
	init_TIMER0();
	init_TIMER2();
	lcd_init(LCD_DISP_ON);		// Initialize display, cursor off
	init_IO();
	init_external_interrupts();

	sei();						// Enable Global Interrupts

	lcd_welcome_screen();		
	lcd_fast_refresh();
	
	SMCR |= (1 << SE);			// Enable sleep mode
}

void init_TIMER0(void)					// 500Hz Clock Initialization (Timer Counter 0)
{
	TCCR0A |= (1 << CS02);					// 256 Prescaler
	TCNT0 = 130;							// Set initial counter value(2ms)
	TIMSK0 |= (1 << TOIE0);					// Overflow Interrupt Enable
}

void init_TIMER2(void)					//   4Hz Clock Initialization (Timer Counter 2)
{
		ASSR  = (1<< AS2);						// Enable asynchronous mode
		TCNT2 = 192;							// Set initial counter value(0.25 Seconds)
		TCCR2A |= (1 << CS02)|(1 << CS00);		// 128 Prescaler ((255*128)/32.786 = 1Hz)
		TIFR2   = (1 << TOV2);					// Clear interrupt flags
		TIMSK2  = (1 << TOIE2);					// Enable TOV2 interrupt
}

void init_ADC(void)						// ADC Initialization
{
		DDRF = 0x00;											// PortF All Inputs
		PORTF = 0x00;											// PortF Pullup Disabled	
	
		ADCSRA |= (1 << ADEN);									// Enable ADC
		ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);	// 128 PreScaler
		ADMUX &= ~((1<<REFS0)|(1<<REFS1));
		ADCSRA |= (1 << ADIE);									// Enable ADC Interrupt
}

void init_IO(void)						// Initialize Input and Output Ports and Pins
{
	DDRE &=~ ((1 << bluebutton) | (1 << greenbutton) | (1 << MCoverheating));		// Inputs
	PORTE |= ((1 << bluebutton) | (1 << greenbutton));		// Pull-up enabled
	
	DDRD &=~ ((1 << button1) | (1 << button2));				// Inputs
	PORTD |= ((1 << button1) | (1 << button2));				// Pull-up enabled

	PORTF |= 0xff;											// Enable pull-up resistors on the whole ADC Port
	
	DDRC |= 0xff;											// PORTC are all output
	PORTC &= 0;												// Set all outputs on PortC standard to logic 0
}

void init_external_interrupts(void)		// Initialize External Interrupts
{
	EIMSK |= (1 << INT6 | (1 << INT7) | (1 << INT0) | (1 << INT1));					// Enable External Interrupts
	EICRB  |= (0 << ISC51) | (1 << ISC50);											// Rising edge creates interrupt
}



int main()								// Main function
{
		initMCU();

		while(1){
		SLEEP_MODE_IDLE;						// Sleep while doing nothing, only interrupts can wake the MC
		}
		
}
